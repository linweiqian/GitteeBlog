[{"title":"前端基础面试题","url":"/2022/12/16/前端基础面试题/","content":"\n**TCP和UDP的区别**\ntcp是传输控制协议，基于连接协议，给连接对方提供可靠的传输，一个tcp传输需要经过三次握手四次挥手才能建立会话；\n优点：传输安全，不易丢包\n缺点：传输效率低\nudp是用户传输协议，不建立连接，不需要建立会话，直接发送数据，不可靠传输数据；\n优点：传输效率高\n缺点：易丢包，传输不安全\n\n--------------------------------------------------------------------------------------------------------------------------\n<!--more-->\n**什么是语义化标签，为什么要语义化**\n什么是：旨在让标签有自己的含义。\n为什么：\n1),.即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构；\n2).语义化HTML会使HTML结构变的清晰，有利于维护代码和添加样式；\n3).方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；\n4).提升搜索引擎优化(SEO)的效果。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：\n5).爬虫依赖于标签来确定上下文和各个关键字的权重；\n6).便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。\n7).通常语义化HTML会使代码变的更少，使页面加载更快。\n\n--------------------------------------------------------------------------------------------------------------------------\n**清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法；**\n什么时候？对元素进行了浮动(float)时，我们的元素就会脱离文档流；\n方法？方法一：添加新的元素 应用 clear：both； \n          方法二：父级div定义 overflow: auto\n          方法三： 据说是最高大上的方法 :after 方法\n\n--------------------------------------------------------------------------------------------------------------------------\n**JavaScript有哪几种数据类型？**\n基本数据类型\n1).字符串'String';2.数字Number；3布尔’Boolean‘\n引用数据类型\n1).数组’Array‘\n2).对象’Object‘\n特殊数据类型\n1).空对象null\n2).未定义Undefined\n\n--------------------------------------------------------------------------------------------------------------------------\n**行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？**\n行内元素：a b span  img input select strong\n块级元素：div ul li ol dl dt dd h1 p\n空元素：`<br> <hr> <img> <input> <link> <meta> `\n\n--------------------------------------------------------------------------------------------------------------------------\n**Label的作用是什么？如何使用？**\n作用：Label标签是用来定义表单控制间的关系\n使用：当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单内容上\n\n--------------------------------------------------------------------------------------------------------------------------\n**HTML5 为什么只需要写 <!DOCTYPE HTML>？**\n告知浏览器的解析器用什么文档标准解析这个文档\n\n--------------------------------------------------------------------------------------------------------------------------\n**一个CSS文件如果过大的话，加载会很慢，占用过大带宽，如果解决？**\n1.去除空格和换行,压缩css代码;\n2.尽量使用简写, 缩减代码;\n3.将css文件分成多个文件  \n\n--------------------------------------------------------------------------------------------------------------------------\n**标签的隐藏（display:none和visibility:hidden）的区别？**\ndisplay:none是彻底消失，不在文档流中占位，浏览器也不会解析该元素；\nvisibility:hidden是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；\n\n--------------------------------------------------------------------------------------------------------------------------\n **input中disabled与readonly有何区别？**\n1）、Readonly只针对input(text / password)和textarea有效，\n而disabled对于所有的表单元素都有效，\n2）、但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，\n而readonly会将该值传递出去（readonly接受值更改可以回传，disable接受改但不回传数据）。\n\n--------------------------------------------------------------------------------------------------------------------------\n **a标签的四个伪类是什么？如何排序？为什么？（link,visited,hover,active）**\n为了产生预期的效果，在 CSS 定义中，a:hover 必须位于 a:link 和 a:visited 之后 !\n为了产生预期的效果，在 CSS 定义中，a:active 必须位于 a:hover 之后！\n\n--------------------------------------------------------------------------------------------------------------------------\n **使用display:inline-block在IE6中不能正常显示，如何解决？**\n1.如果先定义了 display:inline-block，然后再将 display 设回 inline 或 block，\n2.直接让块元素设置为内联对象呈递，然后触发块元素的 layout\n\n--------------------------------------------------------------------------------------------------------------------------\n **img的alt和title有什么区别？**\n1)、alt是在图片不能正常加载时候显示的提示语，\n2)、title属性是鼠标划上去显示的内容\n\n--------------------------------------------------------------------------------------------------------------------------\n**css样式引用和js引入的位置问题（为什么会放在头部或者底部）。**\n因为页面在加载时，css加载时可以并发请求的（同页面中的图片，ie6除外），而js加载时需要等待一个js文件加载完成后才加载其他资源，为了页面的快速呈现，放置在尾部效果更好\n\n--------------------------------------------------------------------------------------------------------------------------\n**某种效果，有两种实现方案都可以实现，**\n   方案一：<img>标签；\n   方案二：背景图，\n   两个方案如何取舍？衡量的标准是什么?\n 如果图像是内容的一部分或图表或人，使用img标签加上alt属性\n 如果你想打印页面并且你想要的图像包含默认情况下使用img\n 使用img（alt文本）图像有一个重要的语义化时\n\n--------------------------------------------------------------------------------------------------------------------------\n**div+css与table布局的有何区别？**\n1).符合W3C标准，代码结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。\n2).布局精准，网站版面布局修改简单。\n3).加快了页面的加载速度（最重要的）。\n4).节约站点所占的空间和站点的流量。\n5.用只包含结构化内容的HTML代替嵌套的标签，提高另外搜索引擎对网页的搜索效率。\n\n--------------------------------------------------------------------------------------------------------------------------\n**table的合并边框属性是什么？跨行是什么？跨列是什么？** \n合并边框“cellspacing” 跨行“rowspan”跨列“colspan”\n\n--------------------------------------------------------------------------------------------------------------------------\n**split() join()的区别在哪？**\n1).join()函数获取一批字符串，然后用分隔符字符串将它们连接起来，从而返回一个字符串。  \n2).split()函数获取一个字符串，然后在分隔符处将其断开，从而返回一批字符串。\n\n--------------------------------------------------------------------------------------------------------------------------\n**数组方法pop() push() unshift() shift()的区别在哪？**\npush()是用来在数组末端添加项，shift()在移除数组的第一个项\npop()在数组末端移除项，unshift()在数组前端添加项。\n\n--------------------------------------------------------------------------------------------------------------------------\n**JavaScript的事件流模型都有哪些？**\n“事件冒泡”：事件开始由最具体的元素接收，然后逐级向上传播\n“事件捕捉”：事件由顶层的dom开始向下传递，在底层最具体的元素接收\n“事件委托”：当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。\n\n--------------------------------------------------------------------------------------------------------------------------\n**请按要求操作数组a：**\n\ti. 如何删除数组a中第2个元素（即：“B”）？\n         a.splice(1,1)\n\tii. 如何删除数组a中最后一个元素？\n         a.pop()\n\tiii. 如何将“NEW”插入数组a的“B”和“C”之间？\n         a..splice(2,0,NEW);\n\n--------------------------------------------------------------------------------------------------------------------------\n**请你谈谈Cookie的弊端**\na. 每个特定的域名下最多生成的cookie个数有限制\nb. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。\nc.有些状态不可能保存在客户端。\nd. cookie存储字段小，为了兼容性，一般不能超过4K\n\n--------------------------------------------------------------------------------------------------------------------------\n**请说出三种减少页面加载时间的方法**\na. 压缩合并Javascript、CSS代码\nb.Javascript脚本放在文件末尾\nc. 服务器开启gzip压缩\nd.网址后加斜杠\ne.减少http请求\n\n--------------------------------------------------------------------------------------------------------------------------\n**列举IE与其他浏览器不一样的特性？**\n1)IE支持currentStyle\n2)IE使用innerText;\n3)滤镜方面：IE：filter:alpha(opacity= num\n4)事件方面：attachEvent\n5)鼠标位置：IE是event.clientX;\n6)IE使用event.Element;\n7)IE中消除list的原点仅需margin:0即可达到最终效果\n\n--------------------------------------------------------------------------------------------------------------------------\n**前端页面有哪三层构成，分别是什么？作用是什么？**\n1)结构层，表现层，行为层\n2作用：\na. 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。\nb. 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。\nc. 行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。\n\n--------------------------------------------------------------------------------------------------------------------------\n**函数里的this什么含义，什么情况下，怎么用。**\n1）this是一个关键词，它始终指向一个对象，this像是一个指针。\n2） 情况一：纯粹的函数调用\n       情况二：作为对象方法的调用 \n       情况三： 作为构造函数调用\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是闭包,闭包的特性、作用**\n闭包：闭包是指有权访问另一个函数作用域中变量的函数\n作用：1）能够读取函数内部的变量\n           2）这些变量长期保存在内存中，不会在外部函数调用后清除\n特性：1）函数套函数\n           2）内部函数可以直接使用外部函数的局部变量或参数\n           3)变量或参数不会被垃圾回收机制回收\n\n--------------------------------------------------------------------------------------------------------------------------\n**undefined和 null 区别**\n1）类型不同\n2）转化出的值不同\n3）含义不同：\nundefined：表示使用var声明变量但没有初始化\nnull：是个空指针对象\n\n--------------------------------------------------------------------------------------------------------------------------\njQuery库中的 $ ()是什么?\n就是jquery对象，$()就是jQuery()，在里面可以传参数，作用就是获取元素\n\n--------------------------------------------------------------------------------------------------------------------------\n\njQuery中，如何阻止事件冒泡和浏览器默认行为？\n1）阻止冒泡用stopagation\n2）阻止浏览器默认行为用preventDefault\n\n--------------------------------------------------------------------------------------------------------------------------\n**怎样添加,移除,移动,复制,创建和查找节点?**\n1）添加用appendChild（）\n2）移除用removeChild（）\n3）移动用cloneNode()\n                removeChild()\n                insertBefore()\n4）复制用cloneNode()\n5）创建用createElement(),createTextNode()\n6）查找用getElementsByTagName()\n                getElementsByClassName()\n                getElementById()\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么叫优雅降级和渐进增强？**\n1)优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n2)渐进增强：针对低版本浏览器构建页面，保证最基本的功能，然后在针对高级浏览器进行效果，交互等改进和追加功能达到最好的效果\n\n--------------------------------------------------------------------------------------------------------------------------\n**Javascript中的定时器有哪些？他们的区别及用法是什么？**\n1）setTimeout(),setInterval()\n区别：setTimeout调用一次,setInterval反复调用\n用法：都可以传入两个参数，一个函数名，另一个为毫秒数\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**innerHTML和outerHTML有什么区别**\n1）innerHTML:\n　　从对象的起始位置到终止位置的全部内容,不包括Html标签。\n2）outerHTML:\n　　除了包含innerHTML的全部内容外, 还包含对象标签本身。\n\n--------------------------------------------------------------------------------------------------------------------------    \n**浏览器的标准模式和怪异模式究竟是什么？**\n\na）标准模式：是浏览器按照W3C标准解析执行代码，这样用规定的语法去渲染，就可以兼容各个浏览器，保证以正确的形式展示网页。\n\nb）怪异模式：是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。\n\n--------------------------------------------------------------------------------------------------------------------------\n**JQuery链式写法原理**\n\n答：jq的链式调用是通过return this的形式来实现的。通过对象上的方法最后加上return this，把对象再返回回来，对象就可以继续调用方法，实现链式操作了。如果需要链式的处理，只需要在方法内部返回当前的这个实例对象this就可以了，因为返回当前实例的this，就又可以访问自己的原型了。\n\n--------------------------------------------------------------------------------------------------------------------------\n **$(document).ready() 是个什么函数？为什么要用它？**\n\n答：该函数会按照注册（绑定）的顺序一次执行，是事件模块中最重要的一个函数，可以极大的提高Web应用程序的响应速度，jQuery就是用(document).ready()方法来代替传统的JS的window.onload方法的\n\n--------------------------------------------------------------------------------------------------------------------------\n**JavaScript window.onload 事件和 jQuery ready 函数有何不同？**\n\n答：前者除了要等待 DOM 被创建还要等到包括大型图片、音频、视频在内的所有外部资源都完全加载。如果加载图片和媒体内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。\n\t另一方面，jQuery ready() 函数只需对 DOM 树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快。使用 jQuery $(document).ready() 的另一个优势是你可以在网页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript window.onload 事件要更好些。\n\n--------------------------------------------------------------------------------------------------------------------------\n\n **$(this) 和 this 关键字在 jQuery 中有何不同?**\n \n\ta、this表示js的dom对象\n\tb、$(this)表示的是用jquery封装好的当前对象,可以使用jquery提供的方法访问样式       \n     \n--------------------------------------------------------------------------------------------------------------------------\n\n\n**px、em、rem的区别**\n\n\tpx: 像素px是相对于显示器屏幕分辨率而言的\n\tem会继承父级元素的字体大小\n\trem会继承html元素的字体大小\n\n\n--------------------------------------------------------------------------------------------------------------------------\n**js页面生命周期**\n\nDOMContentLoaded, 浏览器完成HTML的加载, 并构建DOM树,但是css和img等外部资源尚未加载完成。注意：这里的外部资源指的是需要发送http请求获得的资源，而不是自己文件中的资源\n\nload, 浏览器加载完所有资源, 包括HTML文档, 图片, 样式等\n\nbeforeunload, 用户即将离开, 用来检查用户是否保存了修改, 并询问是否真的要离开\n\nunload, 用户几乎已经离开, 但是可以启动一些操作, 比如发送统计数据\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**有关css属性position的属性值的描述**\n\n\tstatic：没有定位，元素出现在正常的流中，占据文档流空间\n\n\tfixed：生成固定定位的元素，相对于浏览器可视窗口进行定位，不占据文档流空间\n\n\trelative：生成相对定位的元素，相对于元素本身正常位置进行定位，占据文档流空间\n\n\tabsolute：生成绝对定位的元素，相对于static定位以外的第一个含有(relative, absolute, fixed, sticky)的祖先元素定位，不占据文档流空间\n\n\tsticky: 黏贴定位，相对于浏览器可视窗口进行定位，占据文档流空间\n\n\n**主流浏览器、内核 、内核构成以及作用**\n\tIE * trident\n\tFirefox(火狐) * gecko\n\tSafari(苹果) * webkit\n\tChrome(谷歌) * webkit * blink  (blink是webkit内核一个分支)\n\tOpera(欧朋) * presto * webkit (2013改为webkit)\n\n\t内核构成: \n\t\t渲染引擎：负责渲染HTML、CSS、图片等信息，然后输出到显示器\n\t\tjs引擎: 负责解析javascript脚本，实现页面动态效果\n\n--------------------------------------------------------------------------------------------------------------------------\n\n\n\n**css具有继承属性**\n\t color, text-align, line-height, font-size, font-weight, font-style, font-family,\n\t white-space, text-indent, text-decoration, text-transform等等\n\n--------------------------------------------------------------------------------------------------------------------------\n\n\n\n**== 和 ===，null 和 undefined的区别**\n\n\t==:  值相等，类型可以不同\n\t===: 值相等且类型相同\n\n\tnull: 表示暂且空值，未来有值，一般用于释放引用类型数据\n\tundefined: 表示未定义，一般是指一个变量只是生声明而没有赋值\n\n\n--------------------------------------------------------------------------------------------------------------------------\n**css优先级分配**\n\t\n\t含有!important的css的优先级最高\n\n\t在相同选择器精度情况下：\n\t\tid选择器的优先级 > class选择器大 > 元素选择器\n\t\t内联样式 > 内部样式\n\t\t内联样式 > 外部样式\n\n\n\n--------------------------------------------------------------------------------------------------------------------------\n\n\n\n**HTML、XHTML、XML、HTML5区别**\n\n\tHTML: 超级文本标记语言，标签对大小写不敏感\n\tXHTML: 严格的HTML，标签必须小写，标签必须闭合，标签必须嵌套正确\n\tXML: 可扩展的标记语言，标签可以自定义，比如 <car></car>\n\tHTML5: HTML4.0.1升级版\n\n--------------------------------------------------------------------------------------------------------------------------\n**行内元素，行内块元素，块级元素的区别以及标签嵌套规范**\n\n\t行内元素: 不占满整行，不可以直接使用css设置宽度和高度，比如 a, i, span, b, strong, del, s等等\n\n\t行内块元素: 不占满整行，可以直接使用css设置宽度和高度，比如 button, img, input, textarea, select等等\n\n\t块级元素: 占满整行，可以直接使用css设置宽度和高度，比如 div, p, h1-h6, ul, ol, li, form等等\n\n\t标签嵌套规范\n\t\t行内元素可以嵌套行内元素\n\t\t块级元素可以嵌套块级元素、行内块元素、行内元素\n\t\tp元素不能嵌套p元素，p元素不能嵌套h系列的元素，h系列的元素不能嵌套h系列的元素\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**面向对象以及原型**\n\n\t面向对象\n\t\t将需求抽象成一个对象，然后对其成员进行分析\n\n\t面向对象三大特征\n\t\t封装、继承、多态\n\n\t面向对象的第一步是创建构造函数，第二步通过构造函数创建对象实例\n\n\t原型：\n\n\t\t对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象，由于原型本身也是对象，又有自己的原型，所以形成了一条原型链。\n\n\t\t函数的原型是 prototype\n\t\t对象的原型是 __proto__\n\n\t\t对象的顶级原型为null， 即Object.prototype.__proto__ == null\n\n\n\n**外边距合并**\n\t\n\t在垂直方向，两个元素相遇，会发生外边距合并，合并时取最大外边距\n\n\t对于父子元素外边距合并\n\t\t如果父级元素没有内边距和边框，此时设置子元素的外边距，该外边距会和父元素的外边距发生合并\n\t\t解决方法：\n\t\t\t父元素设置边框\n\t\t\t父元素设置内边距替换子元素的外边距\n\n\t对于同级元素外边距合并\n\t\t在垂直方向, 前一个元素设置margin-bottom,后一个设置margin-top, 此时两个元素会发生外边距合并\n\n\t\t解决方法: 只设置元素最大值的外边距\n\n--------------------------------------------------------------------------------------------------------------------------\n**a元素和label元素的作用**\n\n\t对于a元素\n\t\t下载，跳转站外链接，跳转站内链接，回到顶部，锚点\n\n\t对于label元素\n\t\tlabel一般配合表单控件使用\n\t\t使用label元素包裹的表单控件，点击label任何一个范围，相当于点击表单控件\n\t\t使用label的for属性关联表单控件的id，点击label任何一个范围，相当于点击表单控件\n\n--------------------------------------------------------------------------------------------------------------------------\n**判断数组六大方法**\n\n\tarr.constructor === Array\n\tarr instanceof Array\n\n\tArray.isArray(arr)\n\tArray.prototype.isPrototypeOf(arr)\n\n\tObject.getPrototypeOf(arr) === Array.prototype\n\tObject.prototype.toString.call(arr) === '[object Array]'\n\n\n--------------------------------------------------------------------------------------------------------------------------\n**CSS的盒子模型**\n\n\t盒子模型的组成：内容(content)、内边距(padding)、边框(border)、外边距(margin)\n\n\t内边距位于内容和边框之间，一般用于隔离内容，内边距可以填充背景色\n\n\t外边距位于盒子和盒子之间，一般用于隔离盒子，使得盒子与盒子有一定的间距\n\n\t边框位于内边距和外边距之间\n\n--------------------------------------------------------------------------------------------------------------------------\n**js数据类型**\n\n\tjs数据类型分为原始数据类型和引用数据类型\n\n\t\t原始数据类型\n\t\t\tnumber, string, boolean, null, undefined, symbol\n\n\t\t引用数据类型\n\t\t\tfunction, array, object\n\n--------------------------------------------------------------------------------------------------------------------------\n\n\n**$(function() {}) 和 window.onload区别**\n\t\n\n> window.onload是在页面所有的元素都加载完成后才触发 $(function(){})是在页面的dom结构加载完毕后就触发\n> dom里的内容不一定都已经加载完成\n\n--------------------------------------------------------------------------------------------------------------------------\n**内部插入节点和外部插入节点**\n\t\n\t内部插入节点，节点关系为父子关系\n\t\t在父节点尾部添加一个子节点\n\t\t父节点.append(子节点)\n\t\t子节点.appendTo(父节点)\n\n\t\t在父节点顶部添加一个子节点\n\t\t父节点.prepend(子节点)\n\t\t子节点.prependTo(父节点)\n\n\t外部插入节点，节点关系为同胞节点\n\t\t在节点前面添加节点\n\t\t节点1.before(节点2);\n\t\t节点2.insertBefore(节点1);\n\n\t\t在节点后面添加节点\n\t\t节点1.after(节点2);\n\t\t节点2.insertAfter(节点1);\n--------------------------------------------------------------------------------------------------------------------------\n\n**== 和 ===，null 和 undefined的区别**\n\n\t==:  值相等，类型可以不同\n\t===: 值相等且类型相同\n\n\tnull: 表示暂且空值，未来有值，一般用于释放引用类型数据\n\tundefined: 表示未定义，一般是指一个变量只是生声明而没有赋值\n--------------------------------------------------------------------------------------------------------------------------\n\n\n\n**瀑布流实现原理**\n\t先取第一行元素的高度为基准高度，\n\t从第二行开始，在基准高度找出最小高度值，将下一个元素放在最小高度对应的元素的下面，元素完成位置设置后，将基准高度的最小高度重置为元素高度和最小高度之和\n\n--------------------------------------------------------------------------------------------------------------------------\n**$.extend 和 $.fn.extend的区别**\n\n\t$.extend\n\t\t如果只传递一个对象，表示在jQuery构造函数扩展属性和方法，jquery实例不能使用，只能jQuery构造函数本身使用\n\n\t\t如果传递两个对象以上的，表示合并对象，并返回合并之后的对象\n\n\t\t如果第一个参数为true，其他参数为对象时，则表示深度合并对象，并返回合并之后的对象\n\n\t$.fn.extend\n\t\t表示在jQuery构造函数的原型prototype扩展属性和方法, jquery实例能使用, jQuery构造函数本身不能使用\n\n--------------------------------------------------------------------------------------------------------------------------\n**重绘和回流**\n\n\t重绘\n\t\t当页面的元素需要更新属性，新的属性对元素的外观，风格的产生影响，这个更新的过程称为重绘\n\n\t\t比如设置元素的background，color等等，都会重绘元素\n\n\t回流\n\t\t当页面的元素因为尺寸，位置、布局，隐藏等改变而需要浏览器重新构建的过程，这个重构的过程称为回流\n\n\t\t比如设置元素的width，height，float，position等等，都会回流元素\n\n--------------------------------------------------------------------------------------------------------------------------\n\n\n**display: none; 和 visibility: hidden;的区别**\n\t\n\t共同点：都是隐藏元素\n\t不同点: 对于display: none;隐藏的元素不会占据文档流；visibility: hidden;隐藏的元素仍会占据文档流\n\n--------------------------------------------------------------------------------------------------------------------------\n**浏览器的渲染页面机制**\n\n\t浏览器解析HTML文档和CSS样式表构建DOM树和和CSSDOM树(没有设置节点外观样式)\n\n\t浏览器结合DOM树和CSSOM树构建渲染树(重绘元素)\n\n\t浏览器在渲染树内对每个渲染元素进行布局处理，计算出每一个元素的大小和位置(回流元素)\n\n\t遍历渲染树将实际的像素显示到屏幕(确认最终的回流元素样式)\n\n--------------------------------------------------------------------------------------------------------------------------\n**加载优化**\n\n\t懒加载可视区域的数据\n\n\t依赖的下载路径是否可靠，不可用时候是否会阻碍整个页面\n\n\t脚本放在body结束标签之前执行\n\n\t压缩html、图片、样式表、js\n\n\t保证图片正常浏览时，图片分辨率要尽可能小\n\n\t字体图标替换图片\n\n\tcss选择器尽量不要超过四个层级，由于css选择器越复杂，浏览器计算得越久\n\n\t尽量减少js对DOM操作\n\n--------------------------------------------------------------------------------------------------------------------------\n\n\n\n**bootstrap4响应式断点范围**\n\n\t\t超大PC xl: x >= 1200px\n\t\tpc lg: x >= 992px\n\t\t平板 md: x >= 768px\n\t\t手机或者手机横屏 sm:  x >= 576px\n\t\t超小屏幕手机: x < 576\n--------------------------------------------------------------------------------------------------------------------------\n\n**什么是XSS攻击**\n\n   XSS(cross site script): 跨站脚本攻击\n\n   原理: 恶意攻击者往web页面插件恶意的HTML代码, 当用户浏览网页时, 嵌入恶意的html代码就会被执行\n\n   实现原理: 通过站内交互途径, 比如发布评论, 提交含有javascript的内容文本, 如果前端和服务器没有过滤或者没有转义这些脚本, 作为内容发布到网页上, 其他用户访问这个页面时会执行这些脚本, 从而被攻击\n\n   目的: 通过插入恶意脚本, 实现对用户浏览器的控制, 获取用户信息\n\n   **怎样防止XSS攻击**\n\n   \t\t输入过滤(长度验证, 格式验证)\n\n\t\t输出转义(html转义编码)\n\n\t\t将重要的cookie标记httponly, 避免XSS攻击利用javascript的document.cookie获取cookie\n\t\t其中具有httponly标记的cookie无法获取，增强cookie的安全性\n\n--------------------------------------------------------------------------------------------------------------------------\n\n\n\n**有关css属性position的属性值的描述**\n\n\tstatic：没有定位，元素出现在正常的流中，占据文档流空间\n\n\tfixed：生成固定定位的元素，相对于浏览器可视窗口进行定位，不占据文档流空间\n\n\trelative：生成相对定位的元素，相对于元素本身正常位置进行定位，占据文档流空间\n\n\tabsolute：生成绝对定位的元素，相对于static定位以外的第一个含有(relative, absolute, fixed, sticky)的祖先元素定位，不占据文档流空间\n\n\tsticky: 黏贴定位，相对于浏览器可视窗口进行定位，占据文档流空间\n--------------------------------------------------------------------------------------------------------------------------\n\n**前端如何定跳页面**\n\t\n\t利用a标签的href属性跳转页面\n\n\t使用location跳转页面，跳转方式有三种\n\t\tlocation.href\n\t\tlocation.assign()\n\t\tlocaltion.replace()\n\n--------------------------------------------------------------------------------------------------------------------------\n**加载优化**\n\n\t懒加载可视区域的数据\n\n\t依赖的下载路径是否可靠，不可用时候是否会阻碍整个页面\n\n\t脚本放在body结束标签之前执行\n\n\t压缩html、图片、样式表、js\n\n\t保证图片正常浏览时，图片分辨率要尽可能小\n\n\t字体图标替换图片\n\n\tcss选择器尽量不要超过四个层级，由于css选择器越复杂，浏览器计算得越久\n\n\t尽量减少js对DOM操作\n\n--------------------------------------------------------------------------------------------------------------------------\n**目前主流浏览器**\n IE   内核 ：trident\nFirefox    内核：gecko\nSafari (苹果)   内核：webkit\nOpera（欧朋）   内核:webkit\nChrome (谷歌)   内核:webkit\n内核构成：渲染引擎：负责渲染HTML,CSS,图片 等信息，然后输出显示器\njs引擎：负责解析JavaScript脚本，实现页面动态效果\n\n--------------------------------------------------------------------------------------------------------------------------\n**get请求和post请求的区别**\n    get传输数据的速度快，安全性低\n    post传输速递低，安全性高\n\n--------------------------------------------------------------------------------------------------------------------------\n**Sass、LESS 是什么？大家为什么要使用他们？**\n共同点：他们是CSS的预处理器，是CSS上的抽象层，是一种特殊语法，语言编译成CSS;\nLess:是一种动态样式语言，将CSS设置成动态语言的属性，既可以在客户端运行，也可以在服务端运行；\nSass:\n为什么使用？\na.结构清晰，便于扩展。\nb.可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无c.意义的机械劳动。\nd.可以轻松实现多重继承。\ne.完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。\n\n--------------------------------------------------------------------------------------------------------------------------\n**为什么要用面向对象？**\n1.便于项目的维护，拓展更新\n2.可以实现属性和方法的继承\n3.提高网页应用程序的性能，节省内存空间\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是对象？**\n属性和方法的集合，属性和方法是对象的成员\n\n--------------------------------------------------------------------------------------------------------------------------\n**js面向对象创建对象的几种方式：**\n1.直接量定义对象\n2.工厂模式定义对象\n优点：解决看创建相似对象的问题，\n缺点：不能识别对象类型\n3.构造函数定义对象\n优点：创建自定义函数介意将它的实例标识为一种特定的类型\n缺点：每个方法都要重新实例一遍\n4.原型定义对象\n优点：可以让所有的对象实例共享它所包含的属性和方法\n缺点：原型中的所有属性都是共享的，但是实例一般都要有自己单独属性的\n5.混合模型\n\n--------------------------------------------------------------------------------------------------------------------------\n**三种方式定义一个函数**\n1.var fn1= new Function('代码块');//调用fn1()\n2.var fn2 =function(){代码块}；fn2()\n3.function fn3(){代码块}；fn3（）\n自执行函数\n(function(){代码块})（）\n回调函数\n特点：把一个函数作为实参传递到另一个函数再调用\nfunction fn1(callback){\ncallback();\n}\nfn1(function(data){代码块})\n\n--------------------------------------------------------------------------------------------------------------------------\n**CSS中link和@import的区别是？**\n1.lin属于HTML标签，而@import是CSS提供的\n2.link是标签没有兼容性问题，而@import需要ie5以上浏览器\n3.页面被加载时，link标签被同时加载，而@import需要页面加载完再加载\n4.link标签方式的权重高于@import\n\n--------------------------------------------------------------------------------------------------------------------------\n**为什么要初始化样式？**\n由于兼容问题，不同浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异\n\n--------------------------------------------------------------------------------------------------------------------------\n**BFC是什么？**\n独立的布局环境，其中的元素不受外界的影响，并在一个BFC中，块盒和行盒都会垂直沿其父元素的边框排列\n\n--------------------------------------------------------------------------------------------------------------------------\n**对 WEB 标准以及 W3C 的理解与认识**\nW3C可分为结构层，行为层和表现层，而WEB标准是让三者独立，让其具有模块化\nW3C对web标准提出了规范化\n1.对于结构：\na.标签要闭合\nb.标签要小写\nc.标签不能随意嵌套\n2.对于表现和行为：\na.尽量使用外链CSS和JS，符合规范提高渲染速度\nb.不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性\n\n--------------------------------------------------------------------------------------------------------------------------\n**作用域，作用域链？**\na.作用域：就是变量与函数的可访问范围。作用域分为 全局作用域(所声明的变量全局都可以访问),局部作用域(所声明的变量只在其内部可以访问)。\nb.作用域链：当我们在一个函数内部访问当前作用域内不存在的变量时，就会逐层向外查找，如果一直找不到就会报错。当我们在局部作用域中，调用外部变量时，就产生了作用域链。\n\n\n--------------------------------------------------------------------------------------------------------------------------\n**JavaScript的三种强制转化类型**\nParseInt()将一个字符串转化成一个整数\nParseFloat（）将一个字符串转化成一个浮点数\nNumber（）将变量转化成数值型\n\n--------------------------------------------------------------------------------------------------------------------------\n**ajax的理解？**\najax的原理：原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。\najax的优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载可以把前端服务器的任务转接到客服端来处理，减轻服务器负担，节省宽带。\najax的劣势：对搜索引擎的支持比较弱；不容易调试。解决办法：通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效\n\n--------------------------------------------------------------------------------------------------------------------------\n**列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的 常用方法至少5个**\n对象：window document location screen history navigator\n方法：alert() confirm() prompt() open() close() setInterval() setTimeout() clearInterval() clearTimeout()\n\n--------------------------------------------------------------------------------------------------------------------------\n**如何阻止事件冒泡和默认事件 ：**\na.阻止冒泡事件：e. stopPropagation();//标准浏览器\nb.阻止默认事件：e.preventDefault();\n\n--------------------------------------------------------------------------------------------------------------------------\n**javascript 的本地对象，内置对象和宿主对象**\na.本地对象：array obj regexp 等可以 new 实例化\nb.内置对象：gload Math 等不可以实例化的\nc.宿主对象:浏览器自带的 document,window\n\n--------------------------------------------------------------------------------------------------------------------------\n**Sass和Less的区别**\n只要区别是他们的实现方式不同LESS是基于javaScript运行,所以LESS是在客户端处理，Sass是基于Ruby的，在服务端处理的，很多开发者不选择LESS是因为LESS输出修改过的CSS浏览器需要依赖JavaScript引擎，而JavaScript引擎需要额外的时间处理代码\n\n--------------------------------------------------------------------------------------------------------------------------\n**JQuery是什么？特点，优缺点？**\n什么是jQuery：\n1.jQuery是一个优秀的JavaScript框架\n2.是一个轻量级的js库，简洁的js库，能使用户更方便的处理dom，event，实现动画效果，并且方便为网站提供ajax交互\n特点：\n1.一款轻量级的js框架\n2.丰富的dom选择器\n3.链式表达式\n4.事件。样式。动画支持\n5.ajax操作支持\n6.跨浏览器兼容\n7.插件扩展开发\n8.可拓展性强\n优点：\n1.实现脚本与页面分离\n2.最少代码做最多的事情\n3.性能支持比较好\n缺点：\n1.不能向后兼容\n2.插件的兼容性\n3.使用多个插件容易发生冲突\n\n--------------------------------------------------------------------------------------------------------------------------\n**网络七层协议：**\n1.应用层\n2.表示层\n3.会话层\n4.传输层\n5.网络层\n6.数据链路层\n7.物理层\n\n--------------------------------------------------------------------------------------------------------------------------\n**js的常用内置对象**\n1.array数组对象\n2.string字符串\n3.math对象\n4.Date日期对象\n\n--------------------------------------------------------------------------------------------------------------------------\n**js堆栈**\n含义：都是运行时内存分配的一个数据区，因此也被称为堆区和栈区\n区别：\n二者存储的数据类型和处理速度不同\n1.堆用于复杂引用数据类型分配空间，存储速度慢；\n2.栈主要用于存放基本数据类型，存储速度快；\n\n--------------------------------------------------------------------------------------------------------------------------\n**垃圾回收机制**\n1.标记清除：当变量进入执行环境时，变量标记为进入环境，当离开环境时，标记为离开环境，\n2.引用计数：引用计数的含义是跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型赋值给该变量时，这个值的引用次数就是1，相反，如果包含对这个值引用的变量又取得另外一个值，则这个值引用次数就-1；\n\n--------------------------------------------------------------------------------------------------------------------------\n**js由三部分组成**\nECMAscript：它是js语言的标准，规定了js的编程语法和基础核心知识\ndom：文档对象模型，提供给js很多操作页面中元素的属性和方法\nbom：浏览器对象模型，提供给很多操作浏览器的属性和方法，而这些方法都放在window浏览器对象下\n\n--------------------------------------------------------------------------------------------------------------------------\n**Promise是什么**\n是一种异步编程的解决方案，从语法上看，Promise是一个对象，它可以获取异步操作的消息，从本意上看他是一种承诺，承诺一段时间会给你一个结果\n\n--------------------------------------------------------------------------------------------------------------------------\n**同步加载与异步加载？**\n同步模式：\n又称阻塞模式，会阻止浏览器的后续处理，停止后续的解析，只有当前加载完成，才能进行下一步操作。所以默认同步执行才是安全的。但这样如果js中有输出document内容、修改dom、重定向等行为，就会造成页面堵塞\n异步加载：\n又叫非阻塞加载，浏览器在下载执行js的同时，还会继续进行后续页面的处理\n\n--------------------------------------------------------------------------------------------------------------------------\n**Promise的作用？**\n是一个对象，用来传递异步操作的消息，提供统一的api，可供进一步处理\n\n--------------------------------------------------------------------------------------------------------------------------\n**vuex的五个属性有哪些（状态管理模式）**\n1.state：基本数据 （mapState辅助函数）\n2.getters：从基本数据派生的数据\n3.mutations：提交更改数据的方法\n4.actions：像一个装饰器，包裹mutations，使之可以异步\n5.mudules：模块化vuex\n\n--------------------------------------------------------------------------------------------------------------------------\n**vue的虚拟dom 是什么**\n是js模拟dom结构，利用虚拟dom最后的状态去操作dom\n\n--------------------------------------------------------------------------------------------------------------------------\n**常见的八大数据结构：**\n数组\n栈\n队列\n链表\n树\n图\n字典树（这是一种高效的树形结构，但值得单独说明）\n散列表（哈希表）\n\n--------------------------------------------------------------------------------------------------------------------------  \n**foreach和map的区别**\nforeach返回的是一个undefined\nmap返回的是一个新数组\n\n--------------------------------------------------------------------------------------------------------------------------\n**nodejs的优缺点：**\n优点：高并发\n    适合I/O密集型\n缺点：不适合CPU密集型应用\n \t   只支持单核CPU\n    可靠性低\n适合场景：RESTful API\n   统一web应用的UI层\n   大量的ajax请求的应用\n\n---------------------------------------------------------------------------------------------------------------------\n**页面导入样式时，使用link和@import有什么区别？**\n1.link属于XHTML标签，除了加载css外，还能定义rel链接起作用，而@import是css提出的只能加载css\n2.页面被加载时，link会被同时加载，而@import引用的css需要页面加载完再加载\n3.@import需要IE5以上才能识别，而link无兼容问题\n\n---------------------------------------------------------------------------------------------------------------------\n**原型是什么？**\n在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。\n原型链是什么？\n在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。\n\n---------------------------------------------------------------------------------------------------------------------\n**什么是虚拟DOM？**\n使用js对象模拟DOM，在操作过程中不会直接操作DOM，等待虚拟DOM操作完成，仅仅比较开始和结束状态虚拟DOM有哪些变换，最终根据结束状态虚拟DOM去操作DOM。\n\n---------------------------------------------------------------------------------------------------------------------\n**Vue相对于jQuery在开发上有什么优点** \n\t\ta.Vue比JQuery减少了 DOM 操作\n\t\tb.组件化模式，开发效率高,方便维护\n\n---------------------------------------------------------------------------------------------------------------------\n**jsonp原理？**\n使用script标签的src属性，利用get方式请求后台数据，将数据以参数的形式返回\n\n---------------------------------------------------------------------------------------------------------------------\n **怎样避免全局变量污染？**\n\t\ta.尽量少使用全局变量\n\t\tb.使用闭包\n\n---------------------------------------------------------------------------------------------------------------------\n **Vue数据双向绑定的原理及其实现** \n原理是根据数据劫持和订阅者模式\n实现过程是监听器，观察者和解析器\n\n---------------------------------------------------------------------------------------------------------------------\n **MVC与MVVM的理解**\nMVC\n视图层（View）：主要是用户界面的展示\n控制层（Controller）：主要是处理Model层和View层的交互\n模型层（Model）：主要是对数据的CRUD操作辑的处理。\n\nMVVM\n 视图层（View）：调用ViewModel的方法并响应变化。\n 视图模型层（ViewModel）：主要做业务的调度者，分割了View层和Model层。\n 模型（Model）：数据模型\n\n---------------------------------------------------------------------------------------------------------------------\n**GET、POST的区别？**\n\t\ta.get是从服务器上获取数据，post是向服务器传送数据。\n\t\tb.get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制\n\t\tc.get安全性非常低，post安全性较高。\t\n\n---------------------------------------------------------------------------------------------------------------------\n**socket与web socket的区别？**\n\t\tSocket是传输控制层协议，WebSocket是应用层协议。\n\n---------------------------------------------------------------------------------------------------------------------\n**什么是深拷贝，什么是浅拷贝**\n深拷贝是两个对象在同一个内存空间，如果一个改变另一个会开辟新的内存空间，不受影响\n浅拷贝是两个对象，如果一个改变，另一个也会发生改变\n\n---------------------------------------------------------------------------------------------------------------------\n**请讲述sessionStorage、localStorage、cookie的区别？**\n⒈localStorage长期存储数据，浏览器关闭数据后不丢失；\n\n⒉sessionStorage数据在浏览器关闭后自动删除；\n\n⒊cookie是网站为了标识用户身份而存储在用户本地终端（Client   Side）上的数据（通常经过加密）。cookie始终在同源的http请求中携带（即使不需要）都会在浏览器和服务器端间来回传递。session  storage和local storage不会自动把数据发给服务器，仅在本地保存；\n\n⒋存储大小：cookie数据大小不会超过4K，session  storage和local storage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或者更多；\n\n---------------------------------------------------------------------------------------------------------------------\n**如何解决浏览器兼容问题? 另外请详细讲述CSS hack。**\n可以通过初始化样式\ncsshack是通过不同css 代码在不同浏览器中兼容相同效果\n\n---------------------------------------------------------------------------------------------------------------------\n**讲一下 prototype 是什么东西，原型链的理解，什么时候用 prototype**\nprototype是js的对象由属性和方法组成\n原型链是每个prototype对象指向父级对象，最终指向Obeject产生的原型链条\n\n---------------------------------------------------------------------------------------------------------------------\n**js中call(),apply(),bind()方法的区别**\ncall()和apply()第二个传入的参数不同，call()传入的是字符串，apply()传入的是数组\nbind()传参方式与call()相同，只不过call()和apply()调用后会立即执行，而bind()还需要再调用才会执行\n\n---------------------------------------------------------------------------------------------------------------------\n\n**什么是事件委托，它的作用？**\n就是讲子元素的事件，放在父元素去处理，他是原理是事件冒泡的实现\n作用:减少for循环优化性能，减少内存\n\n---------------------------------------------------------------------------------------------------------------------\n**什么是函数防抖？**\n在单位时间内函数只执行最后一次，如果多次触发，则重新计算延迟时间\n应用场景：\n表单提交，输入框验证，搜索框\n\n---------------------------------------------------------------------------------------------------------------------\n**什么是函数节流？**\n在单位时间内多次触发一段时间只一次函数执行\n应用场景:\ndom元素的多次拖拽或滚动，抢购\n\n---------------------------------------------------------------------------------------------------------------------\n\n**什么重绘和回流？**\n重绘：当页面元素样式改变，不影响元素在文档流中的位置\n回流：当操作的改变响应文档内容或者元素在文档流中的位置发生改变\n优化：\n减少dom操作\n将样式放在head标签下而脚本放在body结束后\n简洁优化css样式\n\n---------------------------------------------------------------------------------------------------------------------\n**事件冒泡和事件捕获的区别？**\n事件冒泡是给子元素绑定事件并触发时，父元素也会跟着触发\n事件捕获是用addeventlistener（）绑定并触发子元素时，先触发父元素再传递给子元素\n\n---------------------------------------------------------------------------------------------------------------------\n**什么堆栈？它们的区别**\n\n堆主要存储引用数据类型，存放速度比较慢\n栈主要存储基本数据类型，存取速度比较快 \n\n区别：\n栈存储的是局部变量，堆存放的是实体\n栈的存放速度比堆快\n栈存放的变量生命周期结束就会被摄放，而堆会不定时被垃圾回收机制回收\n\n---------------------------------------------------------------------------------------------------------------------\n**什么是路由守卫？**\n路由守卫是路由跳转时被验证，通常用于登录验证\n传入的参数有to(到哪个页面),from(从哪个页面来),next(回调函数)\n\n---------------------------------------------------------------------------------------------------------------------\n**请描述下你对vue框架的理解？**\nvue是一套用于构建用户界面的渐进式框架\n特性：轻量级框架\n    双向数据绑定\n    插件化\n优点：轻量高性能组件化的MVVM库，容易上手\n缺点：不支持IE8\n   性能不如react和angular\n   \n    \n---------------------------------------------------------------------------------------------------------------------\n**var let const区别?**\n\nvar的声明一般在全局作用域,会有变量提升,会造成变量污染\n\nlet的声明一般在块级作用域,不存在变量提升,形成暂时性死区,不能重复声明\n\nconst的声明一般在块级作用域,形成暂时性死区,不能重复赋值,原因是对简单数据类型的值保存在内存地址,而复杂的数据类型保存的是指向实际数据的内存地址\n\n---------------------------------------------------------------------------------------------------------------------\n\n**promise是什么?**\n\n作为异步编程操作,解决回调地狱,有三个参数,padding(进行中),fulfilled(已成功),rejected(已失败),一旦执行无法中途取消\n\nPromise.prototype.then()等待上一个promise状态改变返回新的promise实例\n\nPromise.prototype.catch()用于指定发生回调函数异步执行的错误\n\nPromise.prototype.try()用于指定发生回调函数同步执行的错误\n\nPromise.prototype.finally()不管 Promise 对象最后状态如何，都会执行的操作\n\nPromise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例,一个执行失败则不会继续执行\n\nPromise.race() 多个相同数据的接口哪个获取快,就先获取哪个的结果\n\nPromise.allSettled()不管每一个操作是成功还是失败，再进行下一步操作\n\nPromise.any()只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。\n\n---------------------------------------------------------------------------------------------------------------------\n\n**async/await是什么?**\npromise和Generater的语法糖,await必须放在async里面\n好处:\n1.简介,使异步代码看起来像同步代码\n\n2.async/await 让 try/catch可以同时处理同步和异步的错误\n\n---------------------------------------------------------------------------------------------------------------------\n\n**箭头函数与普通函数的区别**\n\n1.普通函数存在变量提升的现象\n\n2.箭头函数不能作为构造函数使用,没有new对象\n\n3.两者this的指向不同,普通this指向绑定的事件,箭头函数的this指向所处环境的上下文,如果没有上下文指向最外层的对象window\n\n---------------------------------------------------------------------------------------------------------------------\n**Map和Set的区别?**\n\n1.Map保存键值对，任何值都可以作为键值的值。\n\n2.Set保存的是类数组数据，是值的集合。\n\n3.Map有get方法而Set没有get方法\n\n---------------------------------------------------------------------------------------------------------------------\n**原型和原型链的理解?**\n\n原型:每个函数都有prototype属性,该属性指向原型对象;使用原型对象的好处是所有对象实例共享它所包含的属性和方法\n\n原型链:每个对象都有个原型对象,通过_proto_指针指向原型对象,并从中继承方法和属性,同时原型对象也有原型,这样一层一层最终指向null\n\n原型的作用：\n\n1.数据共享 节约内存内存空间\n\n2.实现继承\n\n\n---------------------------------------------------------------------------------------------------------------------\n\n\n","tags":["前端面试","八股文"],"categories":["八股文"]},{"title":"前端面试题进阶","url":"/2022/12/16/前端面试题进阶/","content":"**冒泡排序**\n\n\n```javascript\nlet arr=[9,2,5,3,7,0]\nfunction arrSort(arr){\n\tfor(var i=0;i<arr.length-1;i++){\n\t\tfor(var j=0;j<arr.length-i-1;j++){\n\t\t\tif(arr[j]>arr[j+1]){\n\t\t\t\tvar tmp = arr[j];\n\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\tarr[j+1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\nconsole.log(arrSort(arr))\n```\n<!--more-->\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**事件冒泡**\n\n```javascript\nfunction StopProgation(e){\n\tif(e.stopPropagation){\n\t\te.stopProgation()\n\t}else{\n\t\te.cancelBubble=true;\n\t}\n}\n```\n\n**取消事件默认行为**\n\n```javascript\nfunction PreventDefault(e){\n\tif(e.preventDefault){\n\t\te.PreventDefault();\n\t}else{\n\t\te.returnValue =false;\n\t}\n}\n```\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**sort排序**\n\n```javascript\nvar arr = new Array(9,2,5,3,7,0);\nfunction arrSort(a,b){\nreturn b-a;\n}\narr = arr.sort(arrSort);\nconsole.log(arr)\n```\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**数组去重**\n\n```javascript\nfunction unique(arr){\nvar array=[];\nfor(var i=0;i<arr.length;i++){\nif(array.indexOf(arr[i])===-1){\narray.push(arr[i]);\n}\n}\nreturn array\n}\nvar arr = [4,4,5,6,6,5,1,2,1,3]\nconsole.log(unique(arr))\n```\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**说一下你对Vue组件复用机制的认识，Vuex的认识 ？**\n\t组件需要注册后才可以使用，注册有全局注册和局部注册两种方式。\n\tVuex是一个专为了vue.js 应用程序开发的状态管理模式\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是深拷贝，什么是浅拷贝，如何实现引用数据类型的深拷贝？**\n\t浅拷贝就是两个对象引用的是同一个的内存空间，一个改变全部改变。\n\t深拷贝就是两个对象，旧对象还是用原来的储存空间。但是新对象就不同了，新对象\n自己开辟了 一个新的空间，自己对自己控制，不再受原来空间的限制。\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**什么是内存泄漏，常见的自动内存管理机制有哪些（至少两个）他们的原理是什么？**\n\t内存泄漏是指无法摄放已经占用的内存空间\n\t标记清除和引用计数\n\t标记清除是通过标记的对象来确定是否清除\n\t引用计数是踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋给该变量时，则这个值的引用次数就是1。如果同一个变量又被赋给另外一个变量，则该值的引用次数加1。相反，如果包含对着值引用的变量又取得了另一个值，则这个值的引用次数减1。\n\n--------------------------------------------------------------------------------------------------------------------------\n\n **Vue数据双向绑定的原理及其实现** \n\ta.vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的\n\t实现过程:\n\t\n\t1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。\n\n\t2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。\n\n\t3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。\n--------------------------------------------------------------------------------------------------------------------------\n\n\n**MVC与MVVM的理解？**\na.MVC\n\t\tMVC模式：指Model、View、Controller三层。\n\n\t\t视图层（View）：主要是用户界面的展示\n\t\t控制层（Controller）：主要是处理Model层和View层的交互，对业务逻\n\t\t模型层（Model）：主要是对数据的CRUD操作辑的处理。\nb.MVVM\n\t\tMVVM模式：指Model、View、ViewModel三层。\n\n\t\t视图层（View）：调用ViewModel的方法并响应变化。\n\t\t视图模型层（ViewModel）：主要做业务的调度者，分割了View层和Model层。\n\t\t模型（Model）：数据模型\n--------------------------------------------------------------------------------------------------------------------------\n**GET、POST的区别？**\n\t\ta.get是从服务器上获取数据，post是向服务器传送数据。\n\t\tb.get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制\n\t\tc.get安全性非常低，post安全性较高。\n\t\t\n--------------------------------------------------------------------------------------------------------------------------\n\n**怎样避免全局变量污染？**\n\t\ta.尽量少使用全局变量\n\t\tb.使用闭包\n     \tES5严格模式的作用和规定？\n\t作用：\ta.消除javascript语法的一些不合理、不严谨之处，减少一些怪异行为\n\t          \tb.消除代码运行的一些不安全性，促进代码运行的安全\n\t         \tc.提高编译器效率，增加运行速度；\n\t          \td.为未来新版本的javascript做好铺垫\n\t规定:\ta、全局变量显示声明\n\n\t\tb、禁止对象属性重名、禁止函数参数重名\n\n\t\tc、禁止使用with语句\n\n\t\td、函数预编译中this默认为undefined\n\t\t\n--------------------------------------------------------------------------------------------------------------------------\n\n**ajax跨域有哪些方法？**\n\t\t方法一:XHR2\n\t\t方法二:服务器跨域\n\t\t方法三:CORS\n\t\t方法四:jsonp\n\tjsonp原理:用了script标签不受同源策略的限制，在页面中动态插入了script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理函数名称告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式传递回去。\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**Vue相对于jQuery在开发上有什么优点** \n\t\ta.Vue比JQuery减少了 DOM 操作\n\t\tb.组件化模式，开发效率高,方便维护\n什么是虚拟DOM：使用js对象模拟DOM，在操作过程中不会直接操作DOM，等待虚拟DOM操作完成，仅仅比较开始和结束状态虚拟DOM有哪些变换，最终根据结束状态虚拟DOM去操作DOM。\n\n--------------------------------------------------------------------------------------------------------------------------\n**string的方法有哪些？**\n\nconcat()连接两个或多个字符串，并返回新的字符串\nsplit()把字符串分割为字符串数组\nsubstr()从起始索引号提取字符串中指定数目的字符\nindexOf(' ')返回字符串指定字符最开始出现的位置\nLastindexOf(' ')返回字符串指定字符最后出现的位置\nreplace()替换匹配的字符串\nslice()提取字符串的片段，并在新的字符串中返回被提取的部分\ntoLocaleLowerCase()把字符串转换成小写\ntoLocaleUpperCase()把字符串准换成大写\ntoLowerCase()把字符串转换成小写\n\n--------------------------------------------------------------------------------------------------------------------------\n**array的方法有哪些？**\n\nslice[start,end]：返回从原数组中指定开始下表到结束下表之间的项组成的新数组（原数组不变）\nsplice()：删除，2个参数，起始位置，删除的项数\npop()：删除数组的最后一个元素，减少数组的长度，返回被删除的值\npush()：将参数添加到数组的最后，返回新数组的长度\nshift()：删除数组的第一个参数，数组的长度减1，无参\nunshift()：像数组的开头添加一个或更多的元素，并返回新的长度。（参数不限）\nsort():按指定的参数对数组进行排序，返回的值是经过排序后的数组（无参，函数）\nconcat()：把两个字符串连接起来，返回的值是一个副本（参数不限）\njoin()：将数组的元素组成一个字符串，以separator（分割器）\nindexOf():从数组的开头向后查找，接受两个参数，要查找的项和查找起点的位置索引\nfoeEach():对数组的每个元素执行一次提供的函数。\nfilter()创建一个新的数组，符合条加的元素并生成新的数组\nfindIndex()返回元素的位置\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是闭包？**\n1.闭包就是能够读取其他函数内部变量的函数\n2.闭包简单理解成\"定义在一个函数内部的函数\"\n3.闭包就是将函数内部和函数外部连接起来的一座桥梁\n作用：读取函数内部的变量，让这些变量的值始终保持在内存中。\n缺点：容易造成内存泄露\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是promise函数？**\n\n 1. promise是实现异步操作的方式,有三个状态，pending(进行中).fulfilled(已成功),rejected(已失败) 优点：解决回调地狱 缺点：一旦执行无法停止，报错不明显\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是async/await？**\n1. async/await是写异步代码的新方式，promise的语法糖\n作用:async能够将函数变成异步，await是等待异步操作执行完\n优点：语法简洁代码直观，报错明显\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**this的指向问题？**\n1.普通函数的this是由动态作用域决定，它总指向于它的直接调用者\n2.在默认情况(非严格模式,未使用 'use strict')，如果函数没有直接调用者，this为window\n在严格模式下,如果函数没有直接调者，this为undefined\n3.call,apply,bind绑定的，this指的是绑定的对象\n\n--------------------------------------------------------------------------------------------------------------------------\n**Vue 路由有哪些?**\n全局守卫:\n1.router.beforeEach\n2.vue router.afterEach\n3.router.beforeResolve\n组件内守卫:\n1.beforeRouteEnter、\n2.beforeRouteUpdate、.\n3.beforeRouteLeave\n路由独享的守卫\nbeforeEnter \n\n--------------------------------------------------------------------------------------------------------------------------\n**vue computed和watch的区别是什么？**\n计算属性computed :\n1、支持缓存，只有依赖数据发生改变，才会重新进行计算\n2、不支持异步，当computed内有异步操作时无效，无法监听数据的变\n3、computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值\n4、如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是多对一或者一对一，一般用computed\n5、如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\n\n侦听属性watch：\n1、不支持缓存，数据变，直接会触发相应的操作；\n2、watch支持异步；\n3、监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；\n4、当一个属性发生变化时，需要执行对应的操作；一对多；\n5、监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，\n\t\t\t\timmediate：组件加载立即触发回调函数执行，\n                deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。\n\n--------------------------------------------------------------------------------------------------------------------------\n**HTTP请求的五个步骤？**\n1.创建XML httprequest 异步对象\n2.创建HTTP请求方式\n3.响应请求\n4.发送请求\n5.获取异步调用返回的数据\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**HTTP请求的事务过程？**\n1.域名解析\n2.发起TCP三次握手\n3.建立TCP链接后发起http请求\n4.服务器响应http后发起请求，浏览器得到html的代码\n5.浏览器解析HTML代码，并得到HTML代码中的资源\n6.浏览器对页面进行渲染呈现给用户\n7.连接结束\n\n--------------------------------------------------------------------------------------------------------------------------\n**es6中map和foreach的区别？**\n相同点：\n1.都是循环遍历数组中的每一项\n2.有三个参数，参数分别为item，index，arr\n3.匿名函数中的this都指向window\n4.只能遍历数组\n不同点：\n1.map(）会分配内存空间存储新数组并返回，foreach()不会返回新数组\n2.forEach()允许callback更改原始数组的元素。map()返回新的数组。\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是事件循环机制？**\njs是一门单线程语言，任务进入执行栈会分为同步任务或异步任务，同步任务会优先在主线程中执行，异步任务会进入到事件队列等待主线程执行完再推到主线程执行，异步队列又分为宏任务和微任务，微任务的执行优先于宏任务，这整个过程称为一个事件循环\n宏任务：setTimeout, setInterval, setImmediate, I/O, UI rendering\n微任务：process.nextTick, promise.then, MutationObserver\n在这里插入图片描述\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021070609295446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021070609295859.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n\n--------------------------------------------------------------------------------------------------------------------------\n**浏览器中400，401,403,404分别代表什么意思？**\n400：请求参数错误\n401：未登录，请授权\n403：跨域拒绝访问\n404：请求地址错误\n\n--------------------------------------------------------------------------------------------------------------------------\n**vue2 和 vue3 数据绑定的区别？**\n\nvue2主要利用es5的object.defineProperty()对数据进行劫持结合发布订阅模式来实现的\nvue3只要利用es6 Proxy api对数据进行代理\n\n```bash\n相比于vue2.x，使用proxy的优势如下\n\ndefineProperty只能监听某个属性，不能对全对象监听\n可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）\n可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化\n```\n--------------------------------------------------------------------------------------------------------------------------\n**什么是原型？**\n\n\n①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象\n②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象\n③所有引用类型的__proto__属性指向它构造函数的prototype\n\n--------------------------------------------------------------------------------------------------------------------------\n**什么是原型链？**\n\n\n当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**箭头函数与普通函数区别？**\n1.箭头函数是匿名函数，不能作为构造函数，不能使用new\n2.箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值\n3.箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。\n4.箭头函数没有原型属性\n\n--------------------------------------------------------------------------------------------------------------------------\n\n**如何提高webpack打包速度？**\n1.利用happyPack并行编译loder\n2.利用dllPlugin先将基本不会改动的代码打包成静态资源\n3.利用缓存，将cache.Directory设置为true\n\n--------------------------------------------------------------------------------------------------------------------------\n**如何利用webpack提高前端性能**\n1.压缩代码，将多余或者注释的代码删除\n2.利用CDN加速，将静态路径修改为对应cdn 的路径\n3.利用treeshaking，将永远不会运行到的代码片段删除掉\n\n--------------------------------------------------------------------------------------------------------------------------\n**vue双向绑定的原理？**\nvue.js采用数据劫持结合订阅和发布的方式，通过object.defineproperty劫持各个属性的set方法和get方法，在数据变动时发布消息给订阅者。触发响应的监听回调\n注意：object.defineproperty的缺点主要是不能直接修改对象或者数组，不能触发组件的重新渲染，而vue3使用proxy代理完美监听任何形式的数据，缺点是兼容性问题\n\n--------------------------------------------------------------------------------------------------------------------------\n**说说对keep-alive的理解?**\n作用在组件切换的时候，保存组件状态防止多次渲染,keep-alive的实现主要通过cache数组缓存所有vnode的实例\n\n--------------------------------------------------------------------------------------------------------------------------\n**$nextTick的原理和作用**\n原理：当执行一个任务时，将任务放到异步队列中，模拟宏任务和微任务，清除异步队列中的方法\n作用：当数据变化后执行某个操作，这个操作需要数据随着dom结构变化而变化的时候\n\n--------------------------------------------------------------------------------------------------------------------------\n**v-show和v-if的区别**\n\n1.v-show是通过设置DOM元素的display样式属性控制显隐；v-if是动态的向DOM树内添加或者删除DOM元素；\n2.v-show只是简单的基于css切换；v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；\n3.v-show适合频繁切换；v-if切换频率低的\n4.v-show性能消耗低，v-if性能消耗大\n————————————————\n版权声明：本文为CSDN博主「嚣张农民」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_40808668/article/details/109091092\n","tags":["前端面试","八股文"],"categories":["八股文"]},{"title":"高频面试之《重绘和回流》","url":"/2022/12/16/高频面试之《重绘和回流》/","content":"## 什么是重绘和回流？\n\n> 重绘: 当页面中元素样式的改变并不影响它在文档流中的位置时，也就是说布局没有发生改变时(比如只是改变元素的颜色)。\n> \n> 回流： 当渲染树(Render Tree)中的部分（或全部）元素的尺寸、结构、显示隐藏等发生改变时，浏览器重新渲染的过程称为回流。\n> \n> 注意：\n> \n> 回流必定会发生重绘，重绘不一定会引发回流。\n> \n> 回流比重绘的代价要更高。有时即使仅仅回流一个单一的元素，它的父元素以及任何跟它相关的元素也会产生回流，牵一发动全身。\n<!--more-->\n## 引起回流的因素？\n\n> （1）添加或者删除可见的 DOM 元素(不可见元素不会触发回流)； \n> （2）元素尺寸或位置发生改变 \n> （3）元素内容变化，比如文字数量或图片大小\n> （4）浏览器窗口大小发生改变 \n> （5）CSS伪类的激活（例如：:hover，从而改变了元素的布局的）\n\n## 如何减少重绘和回流？\n\n> CSS\n> \n> 使用transform代替top； 使用visibility代替display：none，前者引起重绘，后者引发回流；\n> 避免使用table布局； 尽可能在DOM树最末端改变class； 避免设置多层内联样式，css选择符从右往左匹配查找，避免节点层级过多；\n> 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局； 避免使用css表达式，可能会引发回流；\n> css硬件加速；\n> \n\n> JavaScript\n> \n> 避免频繁操作样式，修改class最好； 避免频繁操作DOM，合并多次修改为一次； 避免频繁读取会引发回流/重绘的属性，将结果缓存；\n> 对具有复杂动画的元素使用绝对定位，使他脱离文档流。\n\n","tags":["前端面试","八股文"],"categories":["八股文"]},{"title":"深入了解前端开发规范的区别《Commonjs、AMD、CMD、ES6模块化》","url":"/2022/12/16/深入了解前端开发规范的区别《Commonjs、AMD、CMD、ES6模块化》/","content":"## commonjs规范 （Node.js）:\nCommonJS 主要运行于服务器端，该规范指出，一个单独的文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。 Node.js为主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。\n\n> CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者\n> module.exports 来导出需要暴露的接口\n\n- 优点：CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。\n\n- 缺点：由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。\n<!--more-->\n## AMD 规范（require.js）：\nAMD是\"Asynchronous Module Definition\"的缩写，意思就是\"异步模块定义\"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\n\n> 模块功能主要的几个命令：define、require、return和define.amd。define是全局函数，用来定义模块,define(id?, dependencies?,factory)。require命令用于输入其他模块提供的功能，return命令用于规范模块的对外接口，define.amd属性是一个对象，此属性的存在来表明函数遵循AMD规范。\n\n- 优点：适合在浏览器环境中异步加载模块。可以并行加载多个模块。\n- 缺点：提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。\n## CMD 规范（sea.js）:\n\n> CMD通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。 CMD推崇依赖就近、延迟执行。\n\n- 优点：同样实现了浏览器端的模块化加载。可以按需加载，依赖就近。\n- 缺点：依赖SPM打包，模块的加载逻辑偏重。\n## ES6模块化：\n\n> ES modules（ESM）是 JavaScript 官方的标准化模块系统。\n\n在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。\n\n## 总结：\n- AMD/CMD/CommonJs 是js模块化开发的规范，对应的实现是require.js/sea.js/Node.js\n- CommonJs 主要针对服务端，AMD/CMD/ES Module主要针对浏览器端(服务端一般采用同步加载的方式，浏览器端需要异步加载)\n- AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。\n- CommonJs和ES Module的区别：\n-- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n-- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n-- CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。\n","tags":["前端面试","八股文"],"categories":["八股文"]},{"title":"vue安卓移动端点击input输入框引起布局混乱","url":"/2022/12/16/vue安卓移动端点击input输入框引起布局混乱/","content":"> 问题描述：Vue开发中，当我们相对于父视图的底部布局子控件时，需要用position:fixed，如果页面内容不是很长，没有超出屏幕范围，那就还好，没有问题；一旦超出屏幕范围，当你点击输入框，弹出键盘时，底部固定定位的子控件就会被顶起来。\n> 这个问题在iOS端不会出现，在安卓端会出现，原因是键盘加载方式不一样，这里不作详情解答。\n\n> \n> 解决方案：在键盘弹起时，页面高度变小，底部固定定位上升，所以我们只需要在页面高度变小时，隐藏底部子控件，当键盘消失时再显示底部子控件。\n\n> 解决方法：检测浏览器的resize事件，当高度过小时就可以判定为出现这种情况，这时把定位改成absolute或者直接隐藏掉之类的。\n\n## 第一步： 先在 data 中去 定义 一个记录高度是 属性\n\n<!--more-->\n```javascript\ndata () {\n    return {\n\n        docmHeight: '0',  //默认屏幕高度\n\n        showHeight:  '0',  //实时屏幕高度\n\n        hidshow:true  //显示或者隐藏footer,\n\n       isResize:false //默认屏幕高度是否已获取\n\n    };\n  },\n```\n\n## 第二步： 我们需要将 reisze 事件在 vue mounted 的时候 去挂载一下它的方法\n\n\n```javascript\nmounted() {\n\n    // window.onresize监听页面高度的变化\n\n    window.onresize = ()=>{\n\n        return(()=>{\n\n                     if (!this.isResize) {\n\n                               //默认屏幕高度\n\n                               this.docmHeight: document.documentElement.clientHeight \n\n                               this.isResize = true\n\n                       }\n\n                        //实时屏幕高度\n\n                       this.showHeight = document.body.clientHeight \n\n        })()\n\n    }\n\n  },\n```\n\n## 第三步：watch监控比较，判断按钮是否该显示出来\n\n```javascript\nshowHeight:function() {\n\n        if(this.docmHeight > this.showHeight){\n\n            this.hidshow=false\n\n        }else{\n\n            this.hidshow=true\n\n        }\n\n    }\n```\n\n## 第四步：在模板中给footer添加v-show\n\n```handlebars\n<div class=\"footer\" v-show=\"hidshow\">\n\n移动端点击输入框，弹出键盘，底部被顶起问题\n\n</div>\n\n```\n\n","tags":["vue"],"categories":["vue"]},{"title":"vue 渲染列表报错Avoid using non-primitive value as key, use string_number value instead.  found in","url":"/2022/12/16/vue 渲染列表报错Avoid using non-primitive value as key, use string_number value instead.  found in/","content":"控制台报错\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622141909928.png)\n报错原因说v-for 循环的key值重复了，那就看看自己写的代码\n报错时的代码，如下:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622142203810.png)\n我们可以在v-for循环里面再定义个index值,然后写到key 里面去\n改正后的代码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622142345226.png)\n报错解决，大功告成\n","tags":["vue"],"categories":["vue"]},{"title":"vue引入外部的css文件","url":"/2022/12/16/vue引入外部的css文件/","content":"1.全局引入\n引入外部文件只需在main.js文件中，例如\nimport './assets/YmOrder.css'\n2.局部引入\n在需要用到的vue文件进行局部引入,例如\n<style scoped>\n@import url('./assets/YmOrder.css');\n</style>\n","tags":["vue"],"categories":["vue"]},{"title":"vue 写相对路径图片不显示","url":"/2022/12/16/vue 写相对路径图片不显示/","content":"\n我们一般直接在vue的文件中直接引入路径是不能显示的,如图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622151559220.png)\n原因是因为webpack打包后本地路径丢失，所以我们在data中可以通过require去引入\n改正后的代码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622151911814.png)\n在data中定义值并传入路径\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200622151953826.png)\n欧克欧克，大功告成\n","tags":["vue"],"categories":["vue"]},{"title":"vue-cli 打包后element图标异常不显示问题","url":"/2022/12/16/vue-cli 打包后element图标异常不显示问题/","content":"vue打包后如下element图标不显示\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200623151544162.png)\n控制台报错\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200623151648633.png)\n显示没有找到element-icons资源\n解决办法：\n在build文件下的utils.js文件中添加这一句**publicPath:'../../'**\n找到我如下代码中去添加\n<!--more-->\n```bash\n\n    // Extract CSS when that option is specified\n    // (which is the case during production build)\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader',\n        publicPath:'../../'\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }\n  }\n```\n再打包一次\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200623152101665.png)\n图标显示出来,大功告成\n","tags":["vue"],"categories":["vue"]},{"title":"vue axios常用写法","url":"/2022/12/16/vue axios常用写法/","content":"```bash\naxios({\n                    url: '传入的api',\n                    //对封装好的对象进行序列化,如果后台没说明可以直接传obj对象就行\n                    data: {obj:JSON.stringify(obj)},\n                    //定义get请求或者post请求\n                    method: \"post\",\n                    //设置参数的表头形式，这是表单形式传递\n                    headers: {\n                        \"Content-Type\": 'application/x-www-form-urlencoded'\n                    },\n                    //对data的参数转化为键值对\n                    transformRequest: [function (data) {\n                        let ret = '';\n                        for (let it in data) {\n                            ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&';\n                        }\n                        return ret\n                    }]\n                }).then(res=>{\n                //后台成功请求200运行到这里\n                   console.log(res)\n                    }\n                })\n                    .catch(err=>{\n\t\t\t\t//后台请求失败运行到这里\n                    });\n```\n\n","tags":["vue"],"categories":["vue"]},{"title":"vue终端提示无法加载文件 C__Users_Administrator_AppData_Roaming_npm_vue.ps1，因为在此系统上禁止运行脚本","url":"/2022/12/16/vue终端提示无法加载文件 C__Users_Administrator_AppData_Roaming_npm_vue.ps1，因为在此系统上禁止运行脚本/","content":"**vue : 无法加载文件 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\vue.ps1，因为在此系统上禁止运行脚本**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201125093115892.png#pic_center)\n**解决方法：\n1、管理员身份运行PowerShell（命令提示符，来源于Linux的命令提示符也叫Shell）**\n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020112509321439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70#pic_center)\n**2、执行：set-ExecutionPolicy RemoteSigned （签名或运行这些脚本）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201125093307810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70#pic_center)\n**3.重新在文件创建vue项目：vue create test**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201125093450705.png#pic_center)\n**成功！**\n","tags":["vue"],"categories":["vue"]},{"title":"vue实现简单的tab盒子切换（一）","url":"/2022/12/16/vue实现简单的tab盒子切换（一）/","content":"废话不多说，直接上代码~~~~~~~~~~~\n\nHTML部分\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200918095645423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70#pic_center)\njs部分\n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200918095722334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70#pic_center)\ncss部分\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200918095747228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70#pic_center)\n实现效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200918095845445.gif#pic_center)\n\n","tags":["vue"],"categories":["vue"]},{"title":"vue项目 启动失败报错（实用的解决方法）","url":"/2022/12/16/vue项目 启动失败报错（实用的解决方法）/","content":"第一种报错如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200714004514747.png)\n解决办法：\n直接项目目录下运行`npm install webpack-dev-server -g`\n<!--more-->\n第二种常见报错如下\n如果我们遇到像`Error: Cannot find module '***'`的报错\n我们可以直接项目目录下`npm install 报错提示的***`去进行下载\n示例报错如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200714005003388.png)\n解决办法:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200714005047410.png)\n讲解完毕\n","tags":["vue"],"categories":["vue"]},{"title":"vue 插槽的作用,用插槽slot-scope获取表格中的数据","url":"/2022/12/16/vue 插槽的作用,用插槽slot-scope获取表格中的数据/","content":"\n这里我用了**elementui**的表格组件去做表格,如图\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200703150434734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n我在编辑和删除的组件用**template**去包裹，然后在这个标签去写上**slot-scope=\"scope\"**\n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200703145706564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n然后在需要点击的按钮去添加一个@click事件，在方法中去写上两个参数，第一个参数是当前点击按钮获取的表格在第几行的id,第二个参数是获取表格中当前行的全部参数\n如图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200703150159410.png)\n当我点击表格的第一行时我们看看打印出来的数据\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200703150342536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n现在我们是拿到了当前行的全部数据,大功告成\n\n","tags":["vue"],"categories":["vue"]},{"title":"小白如何快速实现每个月倒计时","url":"/2022/12/16/小白如何快速实现每个月倒计时/","content":"## 代码一\n\n\n```\n//获取这个月最后一天\n    getLastDay(){\n        var year = new Date().getFullYear(); //获取年份\n        var month = new Date().getMonth() + 1; //获取月份\n        var lastDate = new Date(year, month , 0).getDate(); //获取当月最后一日\n        month = month < 10 ? '0' + month : month ; //月份补 0\n        return [year,month ,lastDate ].join(\"-\")\n    },\n//打印后 2022-12-6\n```\n## 代码二\n\n<!--more-->\n```\n//计算倒计时\ncountDownFn() {\n          // 获取当前时间\n          var date = new Date();\n          var getDay = this.getLastDay()\n          var last_mouth = this.getLastDay()+' 0:0:0' //上面我们得到的数据 2022-12-6 0:0:0\n          // 获取当月倒计时时间\n          var tgt = new Date(last_mouth);\n          // console.log(333,tgt,date)\n          // 获取时间差\n          var distance = (tgt - date);\n         //  if (distance <= 0) {\n                // // alert(\"目标时间不能小于当前时间\");\n                // clearInterval(_time);\n                // return;\n         //  }\n          console.log(distance, \"时间差\");\n\n          // 计算剩余时间\n          var d = Math.floor(distance / (1000 * 60 * 60 * 24));//天\n          var h = Math.floor((distance / (1000 * 60 * 60)) % 24);//时\n          var m = Math.floor((distance / (1000 * 60)) % 60);//分\n          var ms = Math.floor(distance/1000 % 60);//秒\n\n          this.time = {\n                  d:d.toString().padStart(2, \"0\"),\n                  h:h.toString().padStart(2, \"0\"),\n                  m:m.toString().padStart(2, \"0\"),\n                  ms:ms.toString().padStart(2,\"0\")\n          }\n},\n```\n## 代码三\n\n\n```\nonShow() {\n        this.destroy_time=setInterval(()=>{\n                this.countDownFn()\t\t  \n        },1000)\n},\n```\n\n## 代码四\n\n\n```\n    destroyed() {\n            clearInterval(this.destroy_time);\n    },\n```\n## 效果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b64f8741bc9746e3892adaef5122d991.png)\n\n","tags":["javascript","vue2","vue3"],"categories":["vue2","vue3","javascript"]},{"title":"新手如何快速用vue导入GLTFLoader模型","url":"/2022/12/16/新手如何快速用vue导入GLTFLoader模型/","content":"\n>Three.js支持包括 .obj、.gltf等类型的模型结构。glTF（GL传输格式）是Khronos的一个开放项目，它为3D资产提供了一种通用的、可扩展的格式，这种格式既高效又与现代web技术高度互操作。\n\n## 一、安装引入Three.js\n\n```\ncnpm install three --save // 很好装的最新版本，可正常引入使用\n```\n\n###  在需要使用3D模型的页面导入包：\n\n<!--more-->\n```\nimport * as Three from \"three\"\n```\n### 在Vue中导入glTF模型需要使用 Three.js 中的 GLTFLoader：\n\n```\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\"\n// GLTF加载器(GLTFLoader)，用于载入glTF 2.0资源的加载器。\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\"\n// OrbitControls是THREEJS中最常用的一个控制器,可以帮助我们实现以目标为焦点的旋转缩放。\n```\n\n## 二、页面DOM元素渲染\n\n### 在Vue中，我们需要使用一个 div 元素来作为3D模型的容器：\n\n```\n<div id=\"container\"></div>\n```\n原理：页面打开之后，Three.js会给 div 元素添加一个 canvas 子元素用来作为3D模型的画布。\n\n## 三、初始化\n\nThree.js中最重要的三大组件:\n\n> 场景——Scene\n>\n> 相机——Camera\n>\n> 渲染器——Renderer\n\n### 代码：\n\n```\nmounted(){\n\n  this.initScene()\n\n  this.initContainer()\n\n  this.initCamera()\n\n  this.initRenderer()\n\n  this.initControls()\n\n},\n\nmethods:{\n\n   initModelContainer() {\n\n   this.model_container = document.getElementById(\"container\");\n\n   this.model_container.style.height = window.innerHeight + \"px\";\n\n   this.model_container.style.width = window.innerWidth + \"px\";\n\n   this.height = this.model_container.clientHeight;\n\n   this.width = this.model_container.clientWidth;\n\n  },\n\n  initScene() {\n\n   this.scene = new Three.Scene();\n\n  },\n\n  initCamera() {\n\n    // 照相机\n\n   this.camera = new Three.PerspectiveCamera(70, this.width / this.height, 0.01, 1000);\n\n   this.camera.position.set(-100, 60, 0);\n\n  },\n\n  initRenderer() {\n\n   this.renderer = new Three.WebGLRenderer({ antialias: true, alpha: true });\n\n   this.renderer.setSize(this.width, this.height);\n\n   // 兼容高清屏幕\n\n   this.renderer.setPixelRatio(window.devicePixelRatio);\n\n    // 消除canvas的外边框\n\n   this.renderer.domElement.style.outline = \"none\";\n\n   this.model_container.appendChild(this.renderer.domElement);\n\n  },\n\n  initControls() {\n\n   this.orbitControls = new OrbitControls(\n\n    this.camera,\n\n    this.renderer.domElement\n\n   );\n\n   // 惯性\n\n   this.orbitControls.enableDamping = true;\n\n   // 动态阻尼系数\n\n   this.orbitControls.dampingFactor = 0.25;\n\n   // 缩放\n\n   this.orbitControls.enableZoom = true;\n\n   // 右键拖拽\n\n   this.orbitControls.enablePan = true;\n\n   // 水平旋转范围\n\n   this.orbitControls.maxAzimuthAngle = Math.PI / 6;\n\n   this.orbitControls.minAzimuthAngle = -Math.PI / 6;\n\n   // 垂直旋转范围\n\n   this.orbitControls.maxPolarAngle = Math.PI / 6;\n\n   this.orbitControls.minPolarAngle = -Math.PI / 6;\n\n  },\n\n}\n```\n\n## 四、导入glTF模型\n\n> 将你的 gltf 模型放在 Vue 项目中的 public 文件夹下，注意，只有将 gltf 模型放在静态资源文件夹下才能被访问到。\n\n\n在钩子函数 mounted 中进行模型加载：\n\n```\nmounted(){\n\n  this.loadModel()\n\n},\n\nmethods:{\n\n  loadModel(){\n\n    let that = this\n\n    // gltf模型加载器\n\n    let loader = new GLTFLoader()\n\n    return new Promise(function(resolve, reject){\n\n      loader.load(\n\n        // 模型在 /public/static/building/文件夹下\n\n        \"static/building/scene.gltf\",\n\n        gltf => {\n\n          console.log(gltf)\n\n          gltf.scene.traverse(object => {\n\n            // 修改模型材质\n\n            let material = ...\n\n            object.material = material\n\n          })\n\n          let group = new Three.Group()\n\n          group.add(gltf.scene)\n\n          let box = new Three.Box3()\n\n          box.setFromObject(group)\n\n          let wrapper = new Three.Object3D()\n\n          wrapper.add(group)\n\n          // 根据自己模型的大小设置位置\n\n          wrapper.position.set(100, -300, 120)\n\n          // 将模型加入到场景中 ! important\n\n          that.scene.add(wrapper)\n\n        },\n\n        xhr => {\n\n          // 模型加载期间的回调函数\n\n          console.log(`${(xhr.loaded / xhr.total) * 100% building model loaded`\n\n      );\n\n        },\n\n        error => {\n\n          // 模型加载出错的回调函数\n\n          console.log(\"error while loading\", error);\n\n          reject(\"load model error\", error);\n\n        }\n\n      )\n\n    })\n\n  }\n\n}\n```\n启动项目，模型导入成功，可以根据自己的需求为模型渲染材质。\n\n## 五、免费下载3D模型的素材网站\n\n[网址一](https://glbxz.com/err/search.php?a=search&keyword=%E5%85%8D%E8%B4%B9&searchtype=titlekeyword&channeltype=0&orderby=&kwtype=0&pagesize=10&typeid=0&TotalResult=63&PageNo=3)\n\n[网址二](https://sketchfab.com/3d-models?date=week&features=downloadable&sort_by=-likeCount)\n","tags":["vue","threejs"],"categories":["vue","threejs"]},{"title":"前端埋点实现方案","url":"/2022/12/16/前端埋点实现方案/","content":"## 前言\n领导今天又来活了😣，要记录每个页面的停留时间，以及页面的操作，是由哪个页面跳转过来的，给每个页面生成GUID上报给服务端，并且需要携带设备型号和设备唯一标识🙄\n\n## 名称解释\n### UV（Unique visitor）\n是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个UV。\n<!--more-->\n### IP（Internet Protocol）\n独立IP是指访问过某站点的IP总数，以用户的IP地址作为统计依据。00:00-24:00内相同IP地址之被计算一次。\n\n UV与IP区别\n\n> 如：你和你的家人用各自的账号在同一台电脑上登录新浪微博，则IP数+1，UV数+2。由于使用的是同一台电脑，所以IP不变，但使用的不同账号，所以UV+2\n\n### PV（Page View）\n即页面浏览量或点击量，用户每1次对网站中的每个网页访问均被记录1个PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。\n\n### VV（Visit View）\n用以统计所有访客1天内访问网站的次数。当访客完成所有浏览并最终关掉该网站的所有页面时便完成了一次访问，同一访客1天内可能有多次访问行为，访问次数累计。\n\n PV与VV区别\n\n> 如：你今天10点钟打开了百度，访问了它的三个页面；11点钟又打开了百度，访问了它的两个页面，则PV数+5，VV数+2.PV是指页面的浏览次数，VV是指你访问网站的次数。\n\n## 埋点分类\n### 代码埋点\n通过代码的方式在页面中嵌入逻辑🎨，比如捕获一个点击事件，在这个点击事件之前加入代码埋点⛑,上报给后台🥐。国内已经有很多成型的服务商了如友盟，百度统计等🌯，都提供了比较成型的方案🎨，并可以在后台管理系统中查看比较详细的数据分析🧵，但是肯定会有领导想要把这些事情掌握在自己的手中，我们就只能通过自身开发来实现代码埋点🍞。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/eaa5c3dc94ac4094a3ebe8a732932e41.png)\n\n优点：\n\n> 控制精准，可以非常精确地选择什么时候发送数据。 传递多样化自定义属性、自定义事件，传递比较丰富的数据到服务端。\n\n缺点：\n\n> 埋点代价比较大，每一个控件的埋点都需要添加相应的代码，不仅工作量大，必须是技术人员才能完成。\n> 更新的代价比较大，每一次更新埋点方案，都必须改代码。\n\n## 可视化埋点\n个人理解的可视化埋点应该是肯定需要第三方的服务商支持🍜，不会有做专门业务的公司去做可视化埋点的解决方案。可视化埋点开发人员除集成采集可视化SDK 外👜，不需要额外去写埋点代码🍠，而是由业务人员或运营人员通过访问分析平台的圈选功能🤔，来“圈”出需要对用户行为进行捕捉的控件🎪，并给出事件命名🚘。圈选完毕后，这些配置会同步到各个用户的终端上😮，由采集SDK按照圈选的配置自动进行用户行为数据的采集和发送🚇。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d62cea6a58ce4f4c932c019f7975a418.png)\n\n 优点：\n\n> 埋点代价小，更新代价小 埋点只需业务同学接入，开发只需对接可视化SDK\n\n缺点：\n\n> 无法做到自定义获取数据 可视化埋点覆盖的功能有限 仅支持客户端行为\n\n## 无痕埋点\n无痕埋点又叫全埋点🥪，网上又很多文章写的都是无痕埋点是将所有事件的操作全部上报😀，但是我们在实现的过程中肯定是不会监听那么多的事件吧😋，但是好像也有第三方服务商sdk集成了所有事件😏。\n\n我的个人理解无痕埋点是针对某一个单一事件，在全局实现监听达到上报，而不是全部事件上报才叫无痕埋点🥙。只要有某个事件在全局实现监听，针对这个事件的埋点方式就称为无痕埋点🌯\n\n优点：\n\n> 由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象。\n> 无埋点方式因为收集的是全量数据，可以大大减少运营和产品的试错成本 如果集成sdk之后无需埋点，方便快捷\n\n缺点：\n\n> 缺点与可视化埋点相同，未解决个性化自定义获取数据的问题，缺乏数据获取的灵活性； 数据量过大，如果不使用第三方服务商，针对自身的服务器是个考验\n\n## 实现方案步骤（uni-app，其他项目逻辑相同）\n### 两方面上报: \n1.事件上报(目前只有点击事件埋点)，2.停留时间上报\n\n**事件上报**：通过给元素绑定自定义指令的方式实现(减少对原有代码的侵入)🍜，将信息存储在缓存池中定时上报，上报之后清空之前的上报信息🥠。\n**停留时间上报**：需要重新封装路由，创建路由拦截在跳转之前记录来源,以及上一个页面的停留时间，当拦截器捕获成功之后🌯，如果发现停留时间大于xx秒进行上报🥙。\n\n> 优点：清晰合理，比较适合新项目。\n> \n> 缺点：针对老项目需要与产品和运营对接埋点方案绑定自定义事件🤪，如果是老项目需要对uni.navigateTo,uni.redirectTo,uni.reLaunch,uni.switchTab\n> 进行二次封装。\n> \n> 问：为什么何将信息存储，而不是实时上报？ 答：考虑到服务器的压力，采用了定时上报的方式。\n> \n> 问：为什么监听停留时长大于XX秒才进行上报？\n> 答：1.服务器的压力问题。2考虑到用户可能做一些没意义的操作，所以停留时长大于XX秒才属于有效页面。\n\n## 实现方法\n### 事件埋点上报\n\n- 在common文件夹下创建自定义指令文件，在main.js中引用该文件。\n\n```bash\nimport Vue from \"vue\";\n// 自定义埋点指令\nVue.directive(\"buried\", {\n  bind: (el, binding) => {\n    if (binding.value) {\n      //这里参数是根据自己业务可以自己定义\n      let params = {\n        currentUrl: binding.value.currentUrl,\n        triggerType: binding.value.triggerType,\n        title: binding.value.title,\n        frontTriggerType: binding.value.triggerType,\n        behavior: binding.value.behavior,\n      };\n      //如果是浏览类型，直接保存,目前只考虑点击类型\n      if (binding.value.triggerType == \"browse\") {\n        console.log(\"browse\", params);\n        //调用后台接口保存数据\n      } else if (binding.value.triggerType == \"click\") {\n        //如果是click类型，监听click事件\n        el.addEventListener(\n          \"click\",\n          () => {\n            // 将操作和内容存储在缓存中定时上报\n            let buriedArray = uni.getStorageSync('buriedArray') //获取埋点集合\n            buriedArray.push(params)  // 将埋点集合存入缓存中\n            uni.setStorageSync('buriedArray', buriedArray)\n          },\n          false\n        );\n      }\n    }\n  },\n});\n```\n\n复制代码\n在app.vue中的onLaunch生命周期中创建定时任务与缓存池,在onHide生命周期中销毁定时任务\n\n```bash\nlet timeInterval = null\nonLaunch(){\n  uni.setStorageSync('buriedArray', [])\n\t\t// 定时上报埋点数据\n\t\ttimeInterval = setInterval(() => {\n\t\t\tif (uni.getStorageSync('buriedArray').length > 0) {\n\t\t\t\t// 上报逻辑，根据需求自行完善\n\t\t\t\tupLoadBuriedInfo(uni.getStorageSync('buriedArray'))\n\t\t\t\t// 上报成功之后清空埋点数据重新上报\n\t\t\t\tuni.setStorageSync('buriedArray', [])\n\t\t\t}\n\t\t}, time)\n}\nonHide: function () {\n\t\ttimeInterval && clearInterval(timeInterval)\n}\n```\n\n\n### 停留时间上报\n\n- 首先读取page.json中的文件获取path和title(原文链接)，先在项目根目录创建一个router文件夹🍞，在vue.config.js里面加入如下代码,这样每次打包之后router文件夹下的index.js中就会生成一个 title和path的对应表。😚\n\n```bash\nconst path = require('path')\nconst fs = require('fs')\n\nconst fromFile = path.join(__filename, '../pages.json')\nconst toFile = path.join(__filename, '../router/index.js')\nconst buffPrefix = Buffer.from('export default ')\n\nconst fileData = fs.readFileSync(fromFile)\n\n// 转成可读的js, 正则删除注释， 不然JSON.parse会报错\nconst fileObj = JSON.parse(fileData.toString().replace(/\\/\\/.*/g, ''))\n\n// 遍历，只取路径和标题，其他的不要，已减小文件体积\nconst routes = fileObj.pages.map(e => {\n\treturn {\n\t\ttitle: e.style ? e.style.navigationBarTitleText ? e.style.navigationBarTitleText : e.name : '未知',\n\t\tpath: '/'+e.path,\n\t}\n})\nfs.writeFileSync(toFile, buffPrefix + Buffer.from(JSON.stringify(routes)))\n\nmodule.exports = {\n\tconfigureWebpack: {\n\t\tplugins: []\n\t}\n}\n```\n\n- 在common中创建routeGuards.js 监听路由拦截，进行上报，在main.js中引用该文件\n\n```bash\nimport Vue from 'vue';\nimport v5 from 'uuid/v5';\nimport UniRouteGuard from '@/js_sdk/pocky-route-gurads/lib';\nimport router from '@/router'\nVue.use(UniRouteGuard);\n\nconst guard = new UniRouteGuard();\n\nlet startTime = Date.now();\nguard.beforeEach((to, from, next) => {\n\tlet currentTime = Date.now();\n\tif (from.url && from.url == '/pages/first/index') {\n\t\tnext()\n\t\treturn\n\t}\n\tconsole.log(router)\n\tif (to.url) {\n\t\tif (to.url.indexOf('?') > -1) {\n\t\t\tto.url = to.url.substr(0, to.url.indexOf('?'))\n\t\t}\n\t}\n\tlet fromName = router.find(item => item.path == from.url) ? router.find(item => item.path == from.url).title : '未知'\n\tlet toName = router.find(item => item.path == to.url) ? router.find(item => item.path == to.url).title : '未知'\n  const stayTime=  parseInt((currentTime - startTime) / 1000)\n\tconst MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';\n\n\tconsole.log(`由${fromName}跳转到${toName}并在${fromName}中停留了${stayTime}秒钟`);\n\tlet params = {\n\t\tfromUrl: from.url, //来源地址\n\t\ttoUrl: to.url, // 目的地址\n\t\tfromName: fromName, // 来源名称\n\t\ttoName: toName, // 目的名称\n\t\tstayTime: stayTime, // 停留时长\n\t\tguid: v5(from.url, MY_NAMESPACE), //页面uuid\n\t\tappUuid: uni.getStorageSync('appUuid') ? uni.getStorageSync('appUuid') : '', // app唯一标识\n\t\tmodel: uni.getStorageSync(\"model\")? uni.getStorageSync('model') : '', // 手机型号\n\t}\n\tconsole.log(params)\n  if(stayTime>10){\n   // 上报逻辑\n    console.log('停留的时间大于10秒钟了，可以进行上报')\n  }\n  startTime = Date.now();\n\tnext();\n});\n```\n\n> 因为uni-app\n> 没有提供自身的路由拦截插件🥠，所以需要我们手动去封装🚘。这种方案针对新项目比较合适，但是针对老项目路由跳转的逻辑都已经通过原生的方式写完了😣，我们在进行封装的话修改的点太多了🤔，所以在网上找到了这个插件不用修改跳转api并且可以获取到上一个页面的路由(全局路由守卫)，原文介绍的是通过npm的方式进行安装，我采用的是hbuilderX导入的方式（有需要的同学可以自行查找）🤙。\n\n## 使用方法\n- 事件埋点:将需要埋点的元素绑定改指令v-buried绑定参数\n\n```bash\n<!-- \ntriggerType: 事件类型\ntitle: 页面标题\ncurrentUrl: 页面路由\nbehavior: 操作行为\n-->\n<view v-buried=\"{\ntriggerType:'click',\ntitle:'我的',\ncurrentUrl: currentPath,\nbehavior:'点击我的收藏按钮'}\">\n</view>\n```\n\n> - 页面跳转\n> \n> 需要在page.json中进行修改如果使用的是自定义导航条或者没有使用导航条需要进行命名\n> 需要将页面中跳转路径修改成绝对路径否则路由会匹配不到\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6bc3cdfa91f64509bb00e47ac88b53fc.png)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8feed268e17145e3b999b3d2492bfc6d.png)\n\n\n\n## uni-app集成友盟统计\n- 首先在友盟上创建一个应用获取其对应的appkey\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0717c8c9c2554d2cb1d6ff9b76a288fd.png)\n\n- 在uni-app的App模块配置中勾选友盟统计并填写对应的key（渠道id随意填写就可以） \n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0624c0f77db46d9b28ae9dddccff0e1.png)\n\n- 这样实际上就在uni-app中集成了友盟统计，如果想看到详细的上报数据可以在友盟后台进行查看（注：必须打包之后或者采用自定义基座的方式才能够进行上报，上报结果可能第二天才会生效，具体上报规则可以查看友盟官网解释）。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/457b53608b284e78bc552a0bc70df7e0.png)\n\n 这样最基本的集成就完成了。\n\n> 那我们如何埋入我们的自定义事件呢，比如我将一个燃气罩加入了购物车把他当成一个事件，并且能在友盟后台查看到我加入商品的属性以及加入空气炸锅或者加入电饼铛的一些数量对比\n\n- 1.在友盟后台注册相应的自定义事件 （我的应用->设置->添加事件） \n![在这里插入图片描述](https://img-blog.csdnimg.cn/509e78b06b3841e4b7fae6047f6b66ea.png)\n\n- 2.创建事件完毕之后在代码中进行上报的代码的编写（步骤一和步骤二谁先谁后都可以）\n\n```bash\n// https://www.html5plus.org/doc/zh_cn/statistic.html 文档链接\n// 第一个参数: 在友盟后台注册的事件id，第二个参数：业务数据\nplus.statistic.eventTrig(\"purchase\", {\"type\":\"book\",\"quantity\":\"3\"});\n复制代码\n```\n\n- 上报可能会有延迟，发行过一段时间之后就可以在友盟后台查看到相关数据。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/486c0e5a58df42809d6ec1111d0070e7.png)\n\n- 点击查看按钮可以看到更详细的数据，以及上报的业务数据对比\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ccbed5f51e8b48ef84822e9cb0251104.png)\n\n\n## uni-app 自带统计\n- 无需集成其他相关sdk只需在manifest.json中勾选uni统计配置即可注：必须打包之后才能够进行上报，上报结果可能第二天才会生效，具体上报规则可以查看uni-app官网解释） \n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0b850d0909324edb81f9cc011c224bd7.png)\n- 查看上报后台\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bb92100c716e4357a501f1a0856a817b.png)\n\n\n- uni统计也支持自定义埋点事件的上报\n\n```bash\n// 注意如果第一个参数是title第二个参数必须是字符串\nuni.report(\"upload\",{\n\t\t\t\t\ttitle: '上报数据',\n\t\t\t\t\tcontent: '上报内容'\n\t\t\t\t})\n```\n\n\n- 可在事件和转化模块中进行查看\n![在这里插入图片描述](https://img-blog.csdnimg.cn/49e0e5b784c144759530ad385adf6fd6.png)\n\n\n在测试uni-app自带的统计中也遇到了一些问题，如果有朋友能够解决的话也可以帮助顶顶帖，我在进行完善问题贴。\n\n## 总结\n针对埋点的方案，自己也是不太熟悉，没有实战经验，找了很多途径，文中可能会有不对的地方，希望小伙伴们可以多多指点。一起加油！🤪 \n","tags":["vue2"],"categories":["vue2"]},{"title":"vue3的7种路由守卫使用大全","url":"/2022/12/16/vue3的7种路由守卫使用大全/","content":"## 路由守卫有哪几种？\n路由守卫(导航守卫)分为三种：全局守卫（3个）、路由独享守卫（1个）、组件的守卫（3个）\n\n\n## 路由守卫的三个参数\n<!--more-->\nto：要跳转到的目标路由\n\nfrom：从当前哪个路由进行跳转\n\nnext：不做任何阻拦，直接通行\n\n注意： 必须要确保 next函数 在任何给定的导航守卫中都被调用过一次。它可以出现多次，但是只能在所有的逻辑路径都不重叠的情况下，否则会报错。\n案例：\n\n```bash\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  else next()\n})\n```\n\n## 一、全局路由守卫\n\n> 全局路由守卫有三个：全局前置守卫，全局后置守卫,全局解析守卫\n\n- 全局前置守卫\n\n1.使用方式：main.js中配置,在路由跳转前触发，这个钩子作用主要是用于登录验证，也就是路由还没跳转提前告知，以免跳转了再通知就为时已晚\n2.代码:\n\n```bash\nrouter.beforeEach((to,from,next)=>{})\n```\n3.例子:做登录判断\n\n```bash\nrouter.beforeEach((to,from,next)=>{\n\n  if(to.path == '/login' || to.path == '/register'){\n\n    next();\n\n  }else{\n\n    alert('您还没有登录，请先登录');\n\n    next('/login');\n\n  }\n\n})\n```\n- 全局后置守卫\n\n1.使用方式：main.js中配置,和beforeEach相反，它是在路由跳转完成后触发，它发生在beforeEach和beforeResolve之后，beforeRouteEnter（组件内守卫）之前。钩子不会接受next函数也不会改变导航本身\n2.代码:\n\n```bash\nrouter.afterEach((to,from)=>{})\n```\n- 全局解析守卫\n1.使用方式：main.js中配置,这个钩子和beforeEach类似，也是路由跳转前触发，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，即在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用。\n2.代码:\n\n```bash\nrouter.beforeResolve((to,from,next)=>{})\n```\n\n## 一、组件内守卫\n\n> 组件内守卫有个三个：路由进入之前beforeRouteEnter，路由离开时beforeRouteLeave,页面更新时beforeRouteUpdate \n\n-  beforeRouteEnter(to, from, next)\n1.使用方式：在组件模板中使用,跟methods: {}等同级别书写，组件路由守卫是写在每个单独的vue文件里面的路由守卫\n2.代码:\n```bash\nbeforeRouteEnter(to, from, next) {\n    // 在组件生命周期beforeCreate阶段触发\n    console.log('组件内路由前置守卫 beforeRouteEnter', this) // 访问不到this\n    next((vm) => {\n      console.log('组件内路由前置守卫 vm', vm) // vm 就是this\n    })\n  },\n```\n- beforeRouteUpdate(to, from, next)\n1.使用方式：在组件模板中使用,跟methods: {}等同级别书写，组件路由守卫是写在每个单独的vue文件里面的路由守卫\n2.代码:\n\n```bash\nbeforeRouteUpdate (to, from, next) {\n    // 同一页面，刷新不同数据时调用，\n    // 可以访问组件实例 \n}\n```\n- beforeRouteLeave(to, from, next)\n1.使用方式：在组件模板中使用,跟methods: {}等同级别书写，组件路由守卫是写在每个单独的vue文件里面的路由守卫\n2.代码:\n\n```bash\nbeforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例\n}\n```\n\n\n## 路由独享守卫\n\n>  路由独享守卫只有一个:进入路由时触发beforeEnter\n\n- 路由独享守卫 beforeEnter(to, from, next)\n1.使用方式：**在router.js中使用**,路由独享守卫是在路由配置页面单独给路由配置的一个守卫\n2.代码\n\n```bash\n\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n\n```\n\n## 导航解析流程\n\n> \n> 1.触发进入其它路由\n2.调用要离开路由的组件守卫beforeRouteLeave\n3.调用全局的前置守卫beforeEach\n4.在重用的组件里调用 beforeRouteUpdate\n5.在路由配置里的单条路由调用 beforeEnter\n6.解析异步路由组件\n7.在将要进入的路由组件中调用beforeRouteEnter\n8.调用全局的解析守卫beforeResolve\n9.导航被确认\n10.调用全局的后置钩子afterEach\n11.触发 DOM 更新mounted\n12.执行beforeRouteEnter守卫中传给 next的回调函数\n\n## 结尾:\n\nvue2和vue3的写法基本一致没有改变\n","tags":["vue"],"categories":["vue"]},{"title":"在spring_boot项目中如何将vue组件引入到.html页面进行使用","url":"/2022/12/16/在spring_boot项目中如何将vue组件引入到.html页面进行使用/","content":"开始我们需要导入我们的vue组件的路径到我们当前的js文件目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200619103950152.png)\n然后我们需要用到一个函数**render**进行渲染，将定义的组件写到**createElements**函数中去\n[想要详细了解render函数的使用可以进入](https://segmentfault.com/a/1190000010913794?utm_source=tag-newest)\n如图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020061910451966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n<!--more-->\n - ~~*在这里我刁侃下我当时是想要通过components函数去添加组件到.html页面去但是失败了，所以才使用了render函数*~~\n接着我们需要在.html文件进行引入我们.js文件\n\n```bash\n<script src=\"./webapp/static/dist/custom.js\"></script>\n```\n我再body标签直接写`<div id=\"app\"></div>`就显示出来了,大功告成\n","tags":["spring_boot","webpack"],"categories":["webpack","工具"]},{"title":"vue无法创建项目create-vite-app projectName，提示错误：create-vite-app _ 无法加载文件 (1)","url":"/2022/12/16/vue无法创建项目create-vite-app projectName，提示错误：create-vite-app _ 无法加载文件 (1)/","content":"运行命令**create-vite-app projectName**创建项目控制台提示报错如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210222221539631.png)\n报错原因：我的是windows10没有管理权限，所以我们需要用管理员身份打开权限\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210222221804323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n<!--more-->\n操作如下：\n1.打开**windows PowerShell**右键点击看到以管理员身份运行点击后打开\n2.输入 **set-ExecutionPolicy RemoteSigned**运行然后出现以下界面再输入**A**或者**Y**即可成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210222222232249.png)\n然后我们在我们编辑器控制台重新输入上面的命令**create-vite-app projectName**创建文件即可成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210222222356918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n\n\n","tags":["vue"],"categories":["vue"]},{"title":"深入了解vue2向vue3变迁过渡的知识点","url":"/2022/12/16/深入了解vue2向vue3变迁过渡的知识点/","content":"\n## TypeScript 类型支持\nvue2.x使用的是Flow来进行开发,但是flow对于一些复杂的场景flow支持的不是很好。\n\nvue3.x中vue全面转向typescript，typescript提供了更好的类型检查，也支持复杂的类型推导。\n<!--more-->\n## vue3移除vue2的实例方法或修饰符\n\n```\n- $children已经被移除。如果要访问子组件，可以使用 $refs\n- $on、 $off、 $once 实例方法被移除\n- vue3对`filter`过滤器过滤器移除,建议议用方法调用或计算属性来替换它们\n- vue3 移除了 $listeners，封装进了 $attrs中\n- 移除了v-on.native 修饰符，触发可用emits对象暴露\n```\n## watch监听数组\nvue3当中，如果想要监听数组内容的变化那么必须要写deep。\n\n## v-if和v-for优先级已更改\nvue2在同一元素`v-for`优先级高于`v-if`,vue3则相反，仍不建议在同一标签同时使用\n\n## 性能优化\n\n- 源码体积优化：移除冷门api、引入tree-shaking实行按需编译\n- 数据劫持优化 proxy\n- 编译优化：diff 算法优化\n- 编译优化：PatchFlag(静态标记)、hoistStatic(静态提升)与渲染复用\n- cacheHandler 事件监听缓存\n- 编译优化：Fragment\n- SSR 服务端渲染\n- StaticNode(静态节点)\n- slot 编译优化\n\n## 生命周期的对比\n\n`beforeCreate` -> setup()\n\n`created` -> setup()\n\n`beforeDestroy` -> `beforeUnmount`\n\n`destroyed` -> `unmounted`\n\n## 创建VUE实例的对比\n\n###  vue2创建\n\n\n```\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nVue({\n  router,\n  store,\n  render: h => h(App)\n}).$mount('#app')\n```\n\n### vue3创建\n\n```\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\ncreateApp(App,{ userName: \"sara\" })\n.use(store)\n.use(router)\n.mount('#app')  \n// createApp 方法返回应用实例本身，因此可以在其后链式调用其它方法\n```\n## 指令的变化\n\n### vue2.x\n\n\n```\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n### vue3.x\n\n```\nconst { createApp } from \"vue\"\nconst app = createApp({})\napp.directive('focus', {\n    mounted(el) {\n        el.focus()\n    }\n})\n```\n\n## Hooks\n\nvue2使用的`mixin`,\nvue3提供了一种新的东西 ，叫做`vue-hooks`\n\n## 响应式数据\n\n在vue2中，实现数据监听使用的是`Object.defineProperty`。我们使用$set。\nvue3使用的是`Proxy`\n\n## v-model 升级\n\n\n> -   变更：在自定义组件上使用`v-model`时， 属性以及事件的默认名称变了\n> -   变更：`v-bind`的`.sync`修饰符在 Vue 3 中又被去掉了, 合并到了`v-model`里\n> -   新增：同一组件可以同时设置多个 `v-model`\n> -   新增：开发者可以自定义 `v-model`修饰符\n\n## 在 prop 的默认函数中访问this\n\n> 生成 prop 默认值的工厂函数不再能访问 this。  \n>取而代之的是：\n>-   组件接收到的原始 prop 将作为参数传递给默认函数；\n>-   inject API 可以在默认函数中使用。\n\n```\nimport { inject } from 'vue'\nexport default {\n  props: {\n    theme: {\n      default (props) {\n        // `props` 是传递给组件的、\n        // 在任何类型/默认强制转换之前的原始值，\n        // 也可以使用 `inject` 来访问注入的 property\n        return inject('theme', 'default-theme')\n      }\n    }\n  }\n}\n```\n## 插槽统一\n\n> 此更改统一了 3.x 中的普通插槽和作用域插槽。  \n> 以下是变化的变更总结：\n> -   this.$slots 现在将插槽作为函数公开\n> -   非兼容：移除 this.$scopedSlots\n\n### vue2.x\n\n\n```\n<!-- 当使用渲染函数，即 h 时，2.x 曾经在内容节点上定义 slot 数据 property。 -->\n// 2.x 语法\n\nh(LayoutComponent, [\n  h('div', { slot: 'header' }, this.header),\n  h('div', { slot: 'content' }, this.content)\n])\n\n<!-- 此外，可以使用以下语法引用作用域插槽： -->\n// 2.x 语法\n\nthis.$scopedSlots.header\n```\n### vue3.x\n\n```\n<!-- 在 3.x 中，插槽以对象的形式定义为当前节点的子节点： -->\n// 3.x Syntax\n\nh(LayoutComponent, {}, {\n  header: () => h('div', this.header),\n  content: () => h('div', this.content)\n})\n\n<!-- 当你需要以编程方式引用作用域插槽时，它们现在被统一到 $slots 选项中了。 -->\n// 2.x 语法\n\nthis.$scopedSlots.header\n\n// 3.x 语法\n\nthis.$slots.header()\n```\n\n\n## 过渡的class名更改\n\n>过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from。\n\n### vue2.x\n\n```\n<!-- 在 v2.1.8 版本之前，每个过渡方向都有两个过渡类：初始状态与激活状态。 -->\n<!-- 在 v2.1.8 版本中，引入了 v-enter-to 来定义 enter 或 leave 变换之间的过渡动画插帧。然而，为了向下兼容，并没有变动 v-enter 类名： -->\n\n.v-enter,\n.v-leave-to {\n  opacity: 0;\n}\n\n.v-leave,\n.v-enter-to {\n  opacity: 1;\n}\n\n<!-- 这样做会带来很多困惑，类似 enter 和 leave 含义过于宽泛，并且没有遵循类名钩子的命名约定。 -->\n```\n### vue3.x\n\n```\n<!-- 为了更加明确易读，我们现在将这些初始状态重命名为： -->\n\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n\n.v-leave-from,\n.v-enter-to {\n  opacity: 1;\n}\n\n<!-- 现在，这些状态之间的区别就清晰多了。 -->\n```\n\n## Transition 作为根节点\n\n\n\n```\n    当使用 <transition> 作为根结点的组件从外部被切换时将不再触发过渡效果\n```\n### vue2.x\n```\n<!-- 在 Vue 2 中，通过使用 <transition> 作为一个组件的根节点，过渡效果存在从组件外部触发的可能性： -->\n<!-- 模态组件 -->\n<template>\n  <transition>\n    <div class=\"modal\"><slot/></div>\n  </transition>\n</template>\n<!-- 用法 -->\n<modal v-if=\"showModal\">hello</modal>\n<!-- 切换 showModal 的值将会在模态组件内部触发一个过渡效果。\n这是无意为之的，并不是设计效果。一个 <transition> 原本是希望被其子元素触发的，而不是 <transition> 自身。\n这个怪异的现象现在被移除了。 -->\n```\n### vue3.x\n    \n```\n<!-- 换做向组件传递一个 prop 就可以达到类似的效果： -->\n\n<template>\n  <transition>\n    <div v-if=\"show\" class=\"modal\"><slot/></div>\n  </transition>\n</template>\n<script>\nexport default {\n  props: ['show']\n}\n</script>\n<!-- 用法 -->\n<modal :show=\"showModal\">hello</modal>\n```\n    \n## Transition Group 根元素\n    \n\n```\n<transition-group> 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素\n```\n### vue2.x\n```\n<!-- 默认情况下，传递给带有 v-on 的组件的事件监听器只能通过 this.$emit 触发。要将原生 DOM 监听器添加到子组件的根元素中，可以使用 .native 修饰符： -->\n\n<my-component\n  v-on:close=\"handleComponentEvent\"\n  v-on:click.native=\"handleNativeClickEvent\"\n/>\n```\n### vue3.x\n\n```\n<!-- v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。 -->\n\n<!-- 因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。 -->\n\n<my-component\n  v-on:close=\"handleComponentEvent\"\n  v-on:click=\"handleNativeClickEvent\"\n/>\n\n// MyComponent.vue\n\n<script>\n  export default {\n    emits: ['close']\n  }\n</script>\n```\n    \n","tags":["vue3"],"categories":["vue3"]},{"title":"简单搭建一个vue3项目","url":"/2022/12/16/简单搭建一个vue3项目/","content":"\n - 第一步\n\n```bash\n$ npm i -g @vue/cli //全局安装最新vue构建工具 (默认最新)\n```\nvuecli安装成功如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0c7ca9da915f4e51aebeb22ae752b3f2.png)\n<!--more-->\n - 第二步\n\n```bash\n$ vue create testvue3    //创建一个名为testvue3的项目\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a792817f6e2844dd9bce71ff42fd65cf.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c5d9781c1e4041a0bede8c85bc048d60.png)\n- 第三步\n执行$ cd testvue3 和$ npm run serve 命令\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f19085e4e57646eea8baea7e80c9e1c9.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cbd79a9b428e49089de456d30b6bbea2.png)\n- 第五步\n\n> 代码文件报错 Parsing error: No Babel config file detected for\n> D:\\xk-project\\demo\\vue.config.js. Either disable config file checking\n> with requireConfigFile: false, or configure Babel so that it can find\n> the config files.eslint\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/45bacc7b24144e69a1b88b7457b7ed70.png)\n在package.json文件,按照下图指示添加\"requireConfigFile\" : false\n![在这里插入图片描述](https://img-blog.csdnimg.cn/12fc91e4454b4516bcb9825b893d04c8.png)\n\n","tags":["vue3"],"categories":["vue3"]},{"title":"新员工webpack打包后上传服务器页面空白","url":"/2022/12/16/新员工webpack打包后上传服务器页面空白/","content":"\n>某天同事小白使用了[webpack](https://so.csdn.net/so/search?q=webpack&spm=1001.2101.3001.7020)开发vue项目，在项目开发完成后，使用命令：npm run build对项目进行打包后发布服务器页面显示空白\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/629f24153fec411087f2b053d0f19aa2.png)\n\n排查后发现：webpack打包的时候引入js时使用的是绝对路径导致的\n<!--more-->\n## 解决方案如下\n\n### 修改webpack打包文件中的配置：\n- **webpack.prod.conf.js**中增加**publicPath:’./’** ；  \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3853a36695a24efa89c14da5273f5e1d.png)\n\n\n- **util.js**中增加**publicPath:’./’**；(可选用或不用)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20ac18a376da47569da6493c4f19d7c6.png)\n\n- **config/index.js**修改**assetsPublicPath：‘./’**;\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1063c7988a0e459c847d2246c7c46acf.png)\n\n","tags":["github","(TortoiseGit)小乌龟"],"categories":["github","工具"]},{"title":"Git小乌龟(TortoiseGit) 简单提交代码到github","url":"/2022/12/16/Git小乌龟(TortoiseGit) 简单提交代码到github/","content":"> 前言:由于提交代码到github时总是要提示验证登录,所以使用ssh提交方式\n\n**第一步:检查本地主机是否已经存在ssh key**\n\n```bash\ncd ~/.ssh\nls\n//看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key\n```\n<!--more-->\n![在这里插入图片描述](https://img-blog.csdnimg.cn/52d2decb1f48482ab99f5fcdc002a34b.png)\n**第二步：生成ssh key**\n如果不存在ssh key，使用如下命令生成\n\n```bash\nssh-keygen -t rsa -C \"xxx@xxx.com\"\n//执行后一直回车即可\n```\n生成完以后再用第二步命令，查看ssh key\n\n**第三步：获取ssh key公钥内容（id_rsa.pub）**\n\n```bash\ncd ~/.ssh\ncat id_rsa.pub\n```\n\n如下图所示，复制该内容\n![在这里插入图片描述](https://img-blog.csdnimg.cn/72eae8753daf42018373a59b4efa418f.png)\n**第四步：Github账号上添加公钥**\n进入Settings设置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/24121ce90bd7436dab547c764cf87cce.png)\n添加ssh key，把刚才复制的内容粘贴上去保存即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f65ac3b01e4f4c09be976577ec20bad0.jpeg)\n**第五步：验证是否设置成功**\n\n```bash\nssh -T git@github.com\n```\n显示如下信息表明设置成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/08f6daec72c24a1c944050f7201a6a29.png)设置成功后，即可不需要账号密码clone和push代码\n**注意之后在clone仓库的时候要使用ssh的url，而不是https！**\n\n**第六步:小乌龟TortoiseGit配置:**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/19b9a11cd3ec48df9804fab07053ed77.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3d169ddd02e143fbaaf506a54d4cd6a7.png)\n**验证原理**\n\n> SSH登录安全性由非对称加密保证，产生密钥时，一次产生两个密钥，一个公钥，一个私钥，在git中一般命名为id_rsa.pub,\n> id_rsa\n> \n> 那么如何使用生成的一个私钥一个公钥进行验证呢？\n> \n>  - 本地生成一个密钥对，其中公钥放到远程主机，私钥保存在本地\n>  -  当本地主机需要登录远程主机时，本地主机向远程主机发送一个登录请求，远程收到消息后，随机生成一个字符串并用公钥加密，发回给本地。本地拿到该字符串，用存放在本地的私钥进行解密，再次发送到远程，远程比对该解密后的字符串与源字符串是否等同，如果等同则认证成功。\n\n**[参考链接跳转](https://blog.csdn.net/weixin_42310154/article/details/118340458)**\n","tags":["github","(TortoiseGit)小乌龟"],"categories":["github","工具"]},{"title":"vscode关于vue项目无法将文件push到github的错误命令","url":"/2022/12/16/vscode关于vue项目无法将文件push到github的错误命令/","content":"\n## 错误提示一:\n\nremote: Invalid username or password.\nfatal: Authentication failed for 'https://github.com/linweiqian/master.git/'\n\n## 错误提示二:\n\nfatal: 'origin' does not appear to be a git repository\nfatal: Could not read from remote repository.\n<!--more-->\n## 错误提示三:\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n## 错误提示四:\n\nfatal: unable to access 'https://github.com/linweiqian/master.git/': Failed to connect to 127.0.0.1 port 1080: Connection refused\n\n## 错误提示五:\n\nOn branch master,nothing to commit, working tree clean\n\n## 错误提示六：\n\nfatal: remote origin already exists.\n\n\n## 解决办法\n\n**重置设置**\n\n```bash\ngit config --global credential.helper store\n```\n\n","tags":["github"],"categories":["github"]},{"title":"vscode 如何将项目放到github上","url":"/2022/12/16/vscode 如何将项目放到github上/","content":"\n首先第一步在github上面创建一个储存库如下操作\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200714010205404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n进入一个新的页面有代码提示如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020071401134119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwODY2OA==,size_16,color_FFFFFF,t_70)\n我们去到我们的vscode项目，在控制台安装上面的提示顺序输入命令就可以完成项目推送\n\n","tags":["github"],"categories":["github"]},{"title":"6种解决移动端1px的方案","url":"/2022/12/16/6种解决移动端1px的方案/","content":"> 在CSS中我们一般使用px作为单位，需要注意的是，CSS样式里面的px和物理像素并不是相等的。CSS中的像素只是一个抽象的单位，在不同的设备或不同的环境中，CSS中的1px所代表的物理像素是不同的。在PC端，CSS的1px一般对应着电脑屏幕的1个物理像素，但在移动端，CSS的1px等于几个物理像素。\n\n## 一、伪元素+transform(常用)\n\n构建1个伪元素, border为1px, 再以transform缩放到50%。\n\n> 对于老项目，有没有什么办法能兼容1px的尴尬问题了，个人认为伪类+transform是比较完美的方法了。 原理是把原先元素的 border\n> 去掉，然后利用 :before 或者 :after 重做 border ，并将 transform 的 scale\n> 缩小一半，原先的元素相对定位，新做的 border 绝对定位。\n<!--more-->\n### 单条border样式设置：\n\n```bash\n.scale-1px{\n  position: relative;\n  border:none;\n}\n.scale-1px:after{\n  content: '';\n  position: absolute;\n  bottom: 0;\n  background: #000;\n  width: 100%;\n  height: 1px;\n  -webkit-transform: scaleY(0.5);\n  transform: scaleY(0.5);\n  -webkit-transform-origin: 0 0;\n  transform-origin: 0 0;\n}\n```\n\n### 四条boder样式设置:\n\n```bash\n.scale-1px{\n  position: relative;\n  margin-bottom: 20px;\n  border:none;\n}\n.scale-1px:after{\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  border: 1px solid #000;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  width: 200%;\n  height: 200%;\n  -webkit-transform: scale(0.5);\n  transform: scale(0.5);\n  -webkit-transform-origin: left top;\n  transform-origin: left top;\n}\n```\n\n最好在使用前也判断一下，结合 JS 代码，判断是否 Retina 屏：\n\n```bash\nif(window.devicePixelRatio && devicePixelRatio >= 2){\n  document.querySelector('ul').className = 'scale-1px';\n}\n```\n\n- 优点：可以满足所有场景，且修改灵活。\n\n- 缺点：对于已使用伪类的元素（例如clearfix）要多层嵌套。\n\n## 二、viewport + rem 实现(常用)\n\n> 同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。\n\n在devicePixelRatio = 2 时，输出viewport：\n\n```bash\n<meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\">\n\n```\n在devicePixelRatio = 3 时，输出viewport：\n\n```bash\n<meta name=\"viewport\" content=\"initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no\">\n```\n\n这种兼容方案相对比较完美，适合新的项目，老的项目修改成本过大。\n\n- 优点：\n\n所有场景都能满足\n一套代码，可以兼容基本所有布局\n- 缺点：\n\n老项目修改代价过大，只适用于新项目\n## 三、使用border-image实现\n\n> 准备一张符合你要求的border-image：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/25dbf1285d0940c398b27a1de06ae24a.png)\n\n\n\n```bash\n.border-bottom-1px {\n  border-width: 0 0 1px 0;\n  -webkit-border-image: url(linenew.png) 0 0 2 0 stretch;\n  border-image: url(linenew.png) 0 0 2 0 stretch;\n}\n```\n\n上文是把border设置在边框的底部，所以使用的图片是2px高，上部的1px颜色为透明，下部的1px使用视觉规定的border的颜色。\n\n- 优点：\n\n可以设置单条、多条表框。\n- 缺点：\n\n更换颜色和样式麻烦，需要更改图片；\n某些设备上会模糊。\n## 四、使用background-image实现\n\n> background-image 跟border-image的方法一样，你要先准备一张符合你要求的图片。然后将边框模拟在背景上。\n> \n样式设置：\n```bash\n\n\n.background-image-1px {\n  background: url(../img/line.png) repeat-x left bottom;\n  -webkit-background-size: 100% 1px;\n  background-size: 100% 1px;\n}\n```\n\n优缺点与border-image一样；\n\n## 五、多背景渐变实现\n\n> 与background-image方案类似，只是将图片替换为css3渐变。设置1px的渐变背景，50%有颜色，50%透明。\n\n样式设置：\n\n```bash\n.background-gradient-1px {\n  background:\n    linear-gradient(#000, #000 100%, transparent 100%) left / 1px 100% no-repeat,\n    linear-gradient(#000, #000 100%, transparent 100%) right / 1px 100% no-repeat,\n    linear-gradient(#000,#000 100%, transparent 100%) top / 100% 1px no-repeat,\n    linear-gradient(#000,#000 100%, transparent 100%) bottom / 100% 1px no-repeat\n}\n/* 或者 */\n.background-gradient-1px{\n  background:\n    -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) left / 1px 100% no-repeat,\n    -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) right / 1px 100% no-repeat,\n    -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) top / 100% 1px no-repeat,\n    -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) bottom / 100% 1px no-repeat\n}\n```\n\n- 优点：\n\n可以实现单条、多条边框\n边框的颜色随意设置\n- 缺点：\n\n代码量不少\n圆角没法实现\n多背景图片有兼容性问题\n\n## 六、使用box-shadow模拟边框\n\n> 利用css 对阴影处理的方式实现0.5px的效果\n\n样式设置：\n\n```bash\n.box-shadow-1px {\n  box-shadow: inset 0px -1px 1px -1px #c8c7cc;\n}\n```\n\n- 优点：代码少，兼容性好。\n- 缺点：边框有阴影，颜色变浅。\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"温故而知新《9种js数组去重方法》","url":"/2022/12/16/温故而知新《9种js数组去重方法》/","content":"\n\n# 一、利用 ES6 Set 去重（ES6 中最常用）\n\n\n```\nfunction unique (arr) {\n  return Array.from(new Set(arr))\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}]\n```\n特点:不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉 `{}` 空对象，后面的高阶方法会添加去掉重复 `{}` 的方法。\n<!--more-->\n# 二、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）\n\n\n```\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个\n                    arr.splice(j,1);\n                    j--;\n                }\n            }\n        }\nreturn arr;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n    //[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {}, {}]  \n\n```\n特点:双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。NaN和{}没有去重，两个null直接消失了\n\n# 三、利用 indexOf 去重\n\n\n```\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexOf(arr[i]) === -1) {\n            array .push(arr[i])\n        }\n    }\n    return array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n   // [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {}, {}] \n\n```\n\n特点:新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则 push 进数组。NaN、{}没有去重。\n\n# 四、利用 sort()\n\n\n```\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return;\n    }\n    arr = arr.sort()\n    var arrry= [arr[0]];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] !== arr[i-1]) {\n            arrry.push(arr[i]);\n        }\n    }\n    return arrry;\n}\n     var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n        console.log(unique(arr))\n// [0, 1, 15, \"NaN\", NaN, NaN, {}, {}, \"a\", false, null, true, \"true\", undefined]     \n\n```\n特点:利用 sort() 排序方法，然后根据排序后的结果进行遍历及相邻元素比对。NaN、{}没有去重。\n\n# 五、利用 includes()\n\n```\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array =[];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n                    array.push(arr[i]);\n              }\n    }\n    return array\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n    //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}]   \n\n```\n特点: {}没有去重\n\n# 六、利用 hasOwnProperty\n\n```\nfunction unique(arr) {\n    var obj = {};\n    return arr.filter(function(item, index, arr){\n        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)\n    })\n}\n    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n        console.log(unique(arr))\n//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}]\n\n```\n特点:利用 hasOwnProperty 判断是否存在对象属性,所有的都去重了\n\n# 七、 利用 filter\n\n```\nfunction unique(arr) {\n  return arr.filter(function(item, index, arr) {\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) === index;\n  });\n}\n    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n        console.log(unique(arr))\n//[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {}, {}]\n\n```\n特点:利用 filter过滤的方法通过索引比对，{}没有去重\n\n# 八、 利用递归去重\n\n\n```\nfunction unique(arr) {\n        var array= arr;\n        var len = array.length;\n\n    array.sort(function(a,b){   //排序后更加方便去重\n        return a - b;\n    })\n\n    function loop(index){\n        if(index >= 1){\n            if(array[index] === array[index-1]){\n                array.splice(index,1);\n            }\n            loop(index - 1);    //递归loop，然后数组去重\n        }\n    }\n    loop(len-1);\n    return array;\n}\n var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n//[1, \"a\", \"true\", true, 15, false, 1, {}, null, NaN, NaN, \"NaN\", 0, \"a\", {}, undefined]\n\n```\n特点:{},NaN没有去重\n\n# 九、利用 Map 数据结构去重\n\n```\nfunction arrayNonRepeatfy(arr) {\n  let map = new Map();\n  let array = new Array();  // 数组用于返回结果\n  for (let i = 0; i < arr.length; i++) {\n    if(map .has(arr[i])) {  // 如果有该key值\n      map .set(arr[i], true); \n    } else { \n      map .set(arr[i], false);   // 如果没有该key值\n      array .push(arr[i]);\n    }\n  } \n  return array ;\n}\n var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n//[1, \"a\", \"true\", true, 15, false, 1, {}, null, NaN, NaN, \"NaN\", 0, \"a\", {}, undefined]\n\n```\n特点:创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。NaN,{}没有去重\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"js解决移动端在iOS和android 监听软键盘弹起、收起","url":"/2022/12/16/js解决移动端在iOS和android 监听软键盘弹起、收起/","content":"\n> 1.在ios中软键盘弹起时，仅会引起$(‘body’).scrollTop值改变，但是我们可以通过输入框的获取焦点情况来做判断，但也只能在ios中采用这个方案，因为在android中存在主动收起键盘后，但输入框并没有失焦，而ios中键盘收起后就会失焦；\n> 2.在android中软键盘弹起或收起时，会改变window的高度，因此监听window的onresize事件；\n\n<!--more-->\n```c\n\n## 一、Android\n\n//获取原窗口的高度\nvar originalHeight=document.documentElement.clientHeight ||document.body.clientHeight;\nwindow.onresize=function(){\n    //键盘弹起与隐藏都会引起窗口的高度发生变化\n       var resizeHeight=document.documentElement.clientHeight || document.body.clientHeight;\n        if(resizeHeight-0<originalHeight-0){\n         //当软键盘弹起，在此处操作\n         }else{\n         //当软键盘收起，在此处操作\n         }\n}\n\n## 二、ios\n\nfocusin和focusout支持冒泡，对应focus和blur, 使用focusin和focusout的原因是focusin和focusout可以冒泡，focus和blur不会冒泡，这样就可以使用事件代理，处理多个输入框存在的情况。\n document.body.addEventListener('focusin', () => {\n            //软键盘弹出的事件处理\n            if(isIphone()）{\n\n            }\n        })\n  document.body.addEventListener('focusout', () => {\n       //软键盘收起的事件处理\n        if(isIphone()）{\n\n        }\n   })\n```\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"javascript 验证是否是手机号并封装","url":"/2022/12/16/javascript 验证是否是手机号并封装/","content":"```bash\n//验证是否是手机号\nfunction isPhoneNumber(str){\n    var myreg = /^[1][3,4,5,6,7,8,9][0-9]{9}$/;\n    if (!myreg.test(str)) {\n        return false;\n    } else {\n        return true;\n    }\n}\n```\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"js对H5链接url进行解密实现过程(vue)","url":"/2022/12/16/js对H5链接url进行解密实现过程(vue)/","content":"\n## https.js文件\n\n```javascript\nimport Vue from 'vue'\nexport default {\n  install(Vue) {\n    Vue.prototype.$getQueryVariable = getQueryVariable\n  }\n};\n//关键部分\nfunction getQueryVariable(queryParams, query) {\n  const query1 = query || window.location.search.substring(1);\n  const vars = query1.split(\"&\");\n  for (let i = 0; i < vars.length; i++) {\n    const pair = vars[i].split(\"=\");\n    if (pair[0] === queryParams) {\n      return pair[1];\n    }\n  }\n  return '';\n}\n```\n<!--more-->\n## vue文件使用部分\n\n```javascript\nlet Base64 = require('js-base64').Base64;\nlet query = Base64.decode(window.location.search.substring(1).split('&')[0]);\n//使用例子\n//对url解码并匹配type的值\nconst type = this.$getQueryVariable('type', query);\n\n```\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"Hello Hexo","url":"/2022/12/14/hello-world/","content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## 快速开始\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["工具","记录","hexo","stun"],"categories":["工具"]}]